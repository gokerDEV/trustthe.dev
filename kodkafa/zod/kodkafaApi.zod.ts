/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * KODKAFA API
 * Stack: Nest.js + MongoDB + Mongoose + Redis - OAuth 2.1 Compliant
 * OpenAPI spec version: 0.0.3
 */
import * as zod from 'zod';

/**
 * @summary Register a new user
 */
export const authControllerRegisterBodyNameMin = 5;
export const authControllerRegisterBodyNameMax = 255;

export const authControllerRegisterBodyPasswordMin = 8;
export const authControllerRegisterBodyPasswordMax = 32;

export const authControllerRegisterBodyUsernameMin = 4;
export const authControllerRegisterBodyUsernameMax = 31;

export const authControllerRegisterBodyEmailMin = 5;
export const authControllerRegisterBodyEmailMax = 255;

export const authControllerRegisterBodyPhoneMin = 12;
export const authControllerRegisterBodyPhoneMax = 18;

export const authControllerRegisterBodyInviteCodeMin = 3;
export const authControllerRegisterBodyInviteCodeMax = 60;



export const authControllerRegisterBody = zod.object({
  "name": zod.string().min(authControllerRegisterBodyNameMin).max(authControllerRegisterBodyNameMax).describe('The name of the User'),
  "password": zod.string().min(authControllerRegisterBodyPasswordMin).max(authControllerRegisterBodyPasswordMax).describe('The password of the user.'),
  "username": zod.string().min(authControllerRegisterBodyUsernameMin).max(authControllerRegisterBodyUsernameMax).optional().describe('The username of the User'),
  "email": zod.string().email().min(authControllerRegisterBodyEmailMin).max(authControllerRegisterBodyEmailMax).optional().describe('The email of the User'),
  "phone": zod.string().min(authControllerRegisterBodyPhoneMin).max(authControllerRegisterBodyPhoneMax).optional().describe('The phone of the user'),
  "inviteCode": zod.string().min(authControllerRegisterBodyInviteCodeMin).max(authControllerRegisterBodyInviteCodeMax).optional().describe('Invitation code')
})


/**
 * @summary Log in a user
 */
export const authControllerLoginBodyPasswordMin = 8;
export const authControllerLoginBodyPasswordMax = 32;

export const authControllerLoginBodyUsernameMin = 4;
export const authControllerLoginBodyUsernameMax = 255;

export const authControllerLoginBodyRememberDefault = false;

export const authControllerLoginBody = zod.object({
  "password": zod.string().min(authControllerLoginBodyPasswordMin).max(authControllerLoginBodyPasswordMax).describe('The password of the user.'),
  "username": zod.string().min(authControllerLoginBodyUsernameMin).max(authControllerLoginBodyUsernameMax).describe('The username, email or sms number of the User'),
  "remember": zod.boolean().optional().describe('Enable long-term login (30 days refresh token). Default: false (1 day)')
})

export const authControllerLoginResponse = zod.object({
  "access_token": zod.string().optional(),
  "refresh_token": zod.string().optional(),
  "token_type": zod.string().optional(),
  "expires_in": zod.number().optional()
})


/**
 * @summary Refresh an access token
 */
export const authControllerRefreshResponse = zod.object({
  "access_token": zod.string().optional(),
  "refresh_token": zod.string().optional(),
  "token_type": zod.string().optional(),
  "expires_in": zod.number().optional()
})


/**
 * @summary Log out the current session
 */
export const authControllerLogoutResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * @summary Initiate password recovery
 */
export const authControllerRecoveryBodyEmailMin = 5;
export const authControllerRecoveryBodyEmailMax = 255;

export const authControllerRecoveryBodyPhoneMin = 12;
export const authControllerRecoveryBodyPhoneMax = 18;



export const authControllerRecoveryBody = zod.object({
  "email": zod.string().email().min(authControllerRecoveryBodyEmailMin).max(authControllerRecoveryBodyEmailMax).optional().describe('The email of the User'),
  "phone": zod.string().min(authControllerRecoveryBodyPhoneMin).max(authControllerRecoveryBodyPhoneMax).optional().describe('The phone of the user')
})

export const authControllerRecoveryResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * @summary Reset password using a recovery token
 */
export const authControllerResetPasswordBody = zod.object({
  "token": zod.string().optional().describe('The recovery token sent to the user.'),
  "password": zod.string().optional().describe('The new password.')
})

export const authControllerResetPasswordResponse = zod.object({
  "access_token": zod.string().optional(),
  "refresh_token": zod.string().optional(),
  "token_type": zod.string().optional(),
  "expires_in": zod.number().optional()
})


/**
 * @summary Change password for an authenticated user
 */
export const authControllerChangePasswordBodyPasswordMin = 8;
export const authControllerChangePasswordBodyPasswordMax = 32;

export const authControllerChangePasswordBodyNewPasswordMin = 8;
export const authControllerChangePasswordBodyNewPasswordMax = 32;



export const authControllerChangePasswordBody = zod.object({
  "password": zod.string().min(authControllerChangePasswordBodyPasswordMin).max(authControllerChangePasswordBodyPasswordMax).describe('The password of the user.'),
  "newPassword": zod.string().min(authControllerChangePasswordBodyNewPasswordMin).max(authControllerChangePasswordBodyNewPasswordMax).describe('The new password of the user.')
})

export const authControllerChangePasswordResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * @summary Get the current user's active sessions
 */
export const authControllerGetSessionsResponseItem = zod.object({
  "key": zod.string().describe('Session key'),
  "device": zod.record(zod.string(), zod.unknown()).describe('Device information (from session)'),
  "browser": zod.record(zod.string(), zod.unknown()).describe('Browser information (from session)'),
  "ip": zod.string().describe('IP address (from session)'),
  "location": zod.record(zod.string(), zod.unknown()).describe('Location information (from session)'),
  "isActive": zod.boolean().describe('Session is active'),
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}).describe('Session creation time'),
  "lastUsedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}).describe('Last used time')
})
export const authControllerGetSessionsResponse = zod.array(authControllerGetSessionsResponseItem)


/**
 * @summary Log out all sessions for the current user
 */
export const authControllerDropAllSessionsResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * @summary Log out a specific session by its key
 */
export const authControllerDropSessionParams = zod.object({
  "key": zod.string()
})

export const authControllerDropSessionResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * Generates the appropriate authentication URL for the specified social provider (e.g., Google, GitHub). The client should redirect the user to this URL.
 * @summary Get OAuth URL for a social provider
 */
export const socialAuthControllerGetSocialAuthUrlParams = zod.object({
  "provider": zod.enum(['google', 'github', 'apple']).describe('The social provider to authenticate with.')
})

export const socialAuthControllerGetSocialAuthUrlResponse = zod.object({
  "url": zod.string().describe('OAuth URL for social login')
})


/**
 * This endpoint is the redirect URI for the social provider. It exchanges the authorization code for user profile information, finds or creates a local user, and returns authentication tokens.
 * @summary Handle the callback from the social provider
 */
export const socialAuthControllerSocialAuthCallbackParams = zod.object({
  "provider": zod.enum(['google', 'github', 'apple']).describe('The social provider calling back.')
})

export const socialAuthControllerSocialAuthCallbackBody = zod.object({
  "code": zod.string().describe('code from the social provider'),
  "state": zod.string().describe('state from the social provider')
})

export const socialAuthControllerSocialAuthCallbackResponse = zod.object({
  "accessToken": zod.string(),
  "expiresIn": zod.number()
})


/**
 * Universal token endpoint supporting client_credentials, authorization_code, and refresh_token grant types. RFC 6749 compliant with form-encoded requests and JSON responses. Requires client authentication (Basic or POST). PKCE validation for authorization_code grant.
 * @summary OAuth 2.1 Token Endpoint
 */
export const oAuthControllerTokenResponseTokenTypeDefault = "Bearer";

export const oAuthControllerTokenResponse = zod.object({
  "access_token": zod.string().describe('The access token (JWT)'),
  "token_type": zod.string().describe('Token type (always \"Bearer\")'),
  "expires_in": zod.number().describe('Token expiration time in seconds'),
  "refresh_token": zod.string().optional().describe('Refresh token (if applicable)'),
  "scope": zod.string().optional().describe('Granted scopes (space-separated)')
})


/**
 * Generates authorization code with PKCE for mobile clients or via PAR for confidential clients. Supports request_uri from POST /oauth/par (RFC 9126). Requires system browser (no embedded WebViews per RFC 8252). Redirects to redirect_uri with code and state parameters.
 * @summary OAuth 2.1 Authorization Endpoint
 */
export const authorizeControllerAuthorizeQueryParams = zod.object({
  "request_uri": zod.string().optional().describe('PAR request URI (RFC 9126)'),
  "response_type": zod.enum(['code']).optional().describe('Response type (only \"code\" supported)'),
  "client_id": zod.string().optional().describe('Client ID'),
  "redirect_uri": zod.string().optional().describe('Redirect URI (must be pre-registered)'),
  "code_challenge": zod.string().optional().describe('PKCE code challenge'),
  "code_challenge_method": zod.enum(['S256']).optional().describe('PKCE code challenge method (only S256 supported)'),
  "state": zod.string().optional().describe('State parameter for CSRF protection (mandatory for direct requests)'),
  "scope": zod.string().optional().describe('Requested scopes (space-separated)')
})


/**
 * Verifies mobile device legitimacy via iOS App Attest or Android Play Integrity. Returns short-lived attestation token for use in authorization code exchange.
 * @summary Device Attestation for Mobile Clients
 */
export const attestControllerAttestBodyNonceMin = 16;



export const attestControllerAttestBody = zod.object({
  "client_id": zod.string().describe('OAuth 2.0 Client ID (must be mobile type)'),
  "platform": zod.enum(['ios', 'android']).describe('Platform identifier'),
  "nonce": zod.string().min(attestControllerAttestBodyNonceMin).describe('Base64url-encoded nonce (minimum 128 bits)'),
  "attestation_token": zod.string().describe('Platform-specific attestation token (iOS: App Attest, Android: Play Integrity)')
})

export const attestControllerAttestResponseTokenTypeDefault = "Bearer";

export const attestControllerAttestResponse = zod.object({
  "attestation_token": zod.string().describe('Short-lived attestation token for use in /oauth/token'),
  "token_type": zod.string().describe('Token type'),
  "expires_in": zod.number().describe('Token expiry in seconds')
})


/**
 * Validates access tokens and returns metadata. Requires confidential client authentication (Basic Auth).
 * @summary Token Introspection (RFC 7662)
 */
export const oAuthControllerIntrospectResponse = zod.object({
  "active": zod.boolean().describe('Whether the token is currently active'),
  "scope": zod.string().optional().describe('Scopes associated with the token (space-separated)'),
  "client_id": zod.string().optional().describe('Client ID'),
  "username": zod.string().optional().describe('Username (email or user ID)'),
  "token_type": zod.string().optional().describe('Token type'),
  "exp": zod.number().optional().describe('Expiration timestamp (Unix time)'),
  "iat": zod.number().optional().describe('Issued at timestamp (Unix time)'),
  "nbf": zod.number().optional().describe('Not before timestamp (Unix time)'),
  "sub": zod.string().optional().describe('Subject (user ID)'),
  "aud": zod.string().optional().describe('Audience'),
  "iss": zod.string().optional().describe('Issuer'),
  "jti": zod.string().optional().describe('JWT ID')
})


/**
 * Returns server metadata including supported endpoints, grant types, and capabilities. Clients can use this for automatic configuration discovery.
 * @summary OAuth 2.0 Authorization Server Metadata (RFC 8414)
 */
export const discoveryControllerGetAuthorizationServerMetadataResponse = zod.object({
  "issuer": zod.string().optional(),
  "authorization_endpoint": zod.string().optional(),
  "token_endpoint": zod.string().optional(),
  "token_endpoint_auth_methods_supported": zod.array(zod.string()).optional(),
  "introspection_endpoint": zod.string().optional(),
  "introspection_endpoint_auth_methods_supported": zod.array(zod.string()).optional(),
  "revocation_endpoint": zod.string().optional(),
  "revocation_endpoint_auth_methods_supported": zod.array(zod.string()).optional(),
  "jwks_uri": zod.string().optional(),
  "response_types_supported": zod.array(zod.string()).optional(),
  "response_modes_supported": zod.array(zod.string()).optional(),
  "grant_types_supported": zod.array(zod.string()).optional(),
  "code_challenge_methods_supported": zod.array(zod.string()).optional(),
  "scopes_supported": zod.array(zod.string()).optional(),
  "service_documentation": zod.string().optional(),
  "ui_locales_supported": zod.array(zod.string()).optional()
})


/**
 * Returns public keys for JWT signature verification. Clients should cache keys and refresh on signature verification failure.
 * @summary JSON Web Key Set (RFC 7517)
 */
export const discoveryControllerGetJWKSResponse = zod.object({
  "keys": zod.array(zod.object({
  "kty": zod.string().optional(),
  "use": zod.string().optional(),
  "kid": zod.string().optional(),
  "alg": zod.string().optional(),
  "n": zod.string().optional(),
  "e": zod.string().optional()
})).optional()
})


/**
 * Allows confidential clients to push authorization parameters to the server before redirecting the user. Returns a request_uri to use in /oauth/authorize. Requires client authentication (HTTP Basic or POST body).
 * @summary Pushed Authorization Request (RFC 9126)
 */
export const pARControllerPushAuthorizationRequestBody = zod.object({
  "response_type": zod.enum(['code']).describe('Response type (only \"code\" supported)'),
  "client_id": zod.string().describe('Client ID'),
  "redirect_uri": zod.string().describe('Redirect URI (must be pre-registered)'),
  "code_challenge": zod.string().optional().describe('PKCE code challenge (optional for confidential clients)'),
  "code_challenge_method": zod.enum(['S256']).optional().describe('PKCE code challenge method'),
  "state": zod.string().optional().describe('State parameter for CSRF protection (recommended)'),
  "scope": zod.string().optional().describe('Requested scopes (space-separated)')
})


/**
 * Returns user claims based on access token scopes. Requires "openid" scope. Additional claims returned based on "profile", "email", "phone", and "address" scopes.
 * @summary OIDC UserInfo Endpoint
 */
export const userInfoControllerGetUserInfoResponse = zod.object({
  "sub": zod.string().describe('Subject - unique identifier for the end-user (REQUIRED)'),
  "name": zod.string().optional().describe('Full name'),
  "given_name": zod.string().optional().describe('Given name(s) or first name(s)'),
  "family_name": zod.string().optional().describe('Surname(s) or last name(s)'),
  "preferred_username": zod.string().optional().describe('Shorthand name by which the End-User wishes to be referred'),
  "picture": zod.string().optional().describe('Profile picture URL'),
  "website": zod.string().optional().describe('Web page or blog URL'),
  "email": zod.string().optional().describe('Email address'),
  "email_verified": zod.boolean().optional().describe('True if email has been verified'),
  "phone_number": zod.string().optional().describe('Phone number in E.164 format'),
  "phone_number_verified": zod.boolean().optional().describe('True if phone number has been verified'),
  "address": zod.object({

}).optional().describe('Postal address'),
  "updated_at": zod.number().optional().describe('Time when information was last updated (Unix timestamp)'),
  "tenant_id": zod.string().optional().describe('Tenant/Project ID (multi-tenant extension)')
})


/**
 * @summary Create an item
 */
export const projectsCrudControllerCreateBody = zod.object({
  "name": zod.string().describe('The name of the project'),
  "description": zod.string().optional().describe('The description of the project'),
  "scopes": zod.array(zod.enum(['openid', 'profile', 'email', 'phone', 'address', 'basic:read', 'basic:write', 'project:read', 'project:write', 'project:delete', 'apikey:read', 'apikey:write', 'user:read', 'user:write', 'user:delete', 'session:read', 'session:write', 'note:read', 'note:write', 'note:delete', 'post:read', 'post:write', 'post:delete', 'files:read', 'files:write', 'files:delete', 'profile:read', 'profile:write', 'user:email:read', 'user:phone:read', 'user:address:read', 'user:profile:read', 'user:profile:write', 'account:read', 'account:write', 'auth:read', 'auth:write', 'user:read:all', 'user:write:all', 'user:delete:all', 'project:users:sessions:read', 'project:users:sessions:delete', 'analytics:read', 'settings:read', 'settings:write', 'webhooks:read', 'webhooks:write', 'configuration:read', 'configuration:write', 'configuration:delete', 'communication:read', 'communication:write', 'communication:delete'])).optional().describe('Available scopes for this project')
})


/**
 * @summary List of all items
 */
export const projectsCrudControllerFindAllResponseItemsItemCreatedByMin = 24;
export const projectsCrudControllerFindAllResponseItemsItemCreatedByMax = 24;

export const projectsCrudControllerFindAllResponseItemsItemIdMin = 24;
export const projectsCrudControllerFindAllResponseItemsItemIdMax = 24;



export const projectsCrudControllerFindAllResponse = zod.object({
  "items": zod.array(zod.object({
  "name": zod.string().describe('The name of the project'),
  "description": zod.string().optional().describe('The description of the project'),
  "scopes": zod.array(zod.enum(['openid', 'profile', 'email', 'phone', 'address', 'basic:read', 'basic:write', 'project:read', 'project:write', 'project:delete', 'apikey:read', 'apikey:write', 'user:read', 'user:write', 'user:delete', 'session:read', 'session:write', 'note:read', 'note:write', 'note:delete', 'post:read', 'post:write', 'post:delete', 'files:read', 'files:write', 'files:delete', 'profile:read', 'profile:write', 'user:email:read', 'user:phone:read', 'user:address:read', 'user:profile:read', 'user:profile:write', 'account:read', 'account:write', 'auth:read', 'auth:write', 'user:read:all', 'user:write:all', 'user:delete:all', 'project:users:sessions:read', 'project:users:sessions:delete', 'analytics:read', 'settings:read', 'settings:write', 'webhooks:read', 'webhooks:write', 'configuration:read', 'configuration:write', 'configuration:delete', 'communication:read', 'communication:write', 'communication:delete'])).optional().describe('Available scopes for this project'),
  "createdBy": zod.string().min(projectsCrudControllerFindAllResponseItemsItemCreatedByMin).max(projectsCrudControllerFindAllResponseItemsItemCreatedByMax).describe('The unique id'),
  "id": zod.string().min(projectsCrudControllerFindAllResponseItemsItemIdMin).max(projectsCrudControllerFindAllResponseItemsItemIdMax).describe('The unique id')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


/**
 * @summary  Add new account to user. 
 */
export const usersAccountsControllerAddBody = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})


/**
 * @summary  Find specific accounts by user id. 
 */
export const usersAccountsControllerFindQueryParams = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})

export const usersAccountsControllerFindResponseItem = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})
export const usersAccountsControllerFindResponse = zod.array(usersAccountsControllerFindResponseItem)


/**
 * @summary Update an account by user id.
 */
export const usersAccountsControllerUpdateBody = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})

export const usersAccountsControllerUpdateResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * @summary Remove specific account by user id. 
 */
export const usersAccountsControllerRemoveBody = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})

export const usersAccountsControllerRemoveResponse = zod.object({
  "message": zod.string().describe('Successfull message')
})


/**
 * @summary Set as primary. 
 */
export const usersAccountsControllerSetPrimaryBody = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})

export const usersAccountsControllerSetPrimaryResponseItem = zod.object({
  "provider": zod.string(),
  "identity": zod.string(),
  "isVerified": zod.boolean(),
  "isPrimary": zod.boolean().describe('Whether this account is the primary account for the user')
})
export const usersAccountsControllerSetPrimaryResponse = zod.array(usersAccountsControllerSetPrimaryResponseItem)


/**
 * @summary Verify OTP and get token
 */
export const otpControllerVerifyBodyCodeMin = 6;
export const otpControllerVerifyBodyCodeMax = 6;



export const otpControllerVerifyBody = zod.object({
  "identifier": zod.string().describe('The identifier for OTP (email, phone, userId, etc.)'),
  "code": zod.string().min(otpControllerVerifyBodyCodeMin).max(otpControllerVerifyBodyCodeMax).describe('6-character OTP code'),
  "type": zod.enum(['invite', 'verify', 'recovery', 'discount', 'reset_password']).describe('Type of OTP operation')
})

export const otpControllerVerifyResponse = zod.object({
  "token": zod.string().describe('The verified token'),
  "message": zod.string().describe('Success message')
})


/**
 * @summary Resend OTP for end user
 */
export const otpControllerResendForUserBody = zod.object({
  "identifier": zod.string().describe('The identifier for OTP (email, phone, userId, etc.)'),
  "type": zod.enum(['invite', 'verify', 'recovery', 'discount', 'reset_password']).describe('Type of OTP operation')
})

export const otpControllerResendForUserResponse = zod.object({
  "message": zod.string().describe('Success message')
})


/**
 * @summary Get all posts with pagination
 */
export const postsQueryControllerFindAllQueryParams = zod.object({
  "limit": zod.number().optional().describe('Number of items to return (1-100, default: 20)'),
  "after": zod.string().optional().describe('Cursor token for next page (forward pagination)'),
  "before": zod.string().optional().describe('Cursor token for previous page (backward pagination)'),
  "sort": zod.enum(['title', 'slug', 'createdAt', 'updatedAt', '-title', '-slug', '-createdAt', '-updatedAt']).optional().describe('Sort field with optional \'-\' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt'),
  "projectId": zod.string().optional().describe('Filter by projectId'),
  "domain": zod.string().optional().describe('Filter by domain (exact match)'),
  "domain.contains": zod.string().optional().describe('Filter where domain contains the value (case-sensitive)'),
  "domain.icontains": zod.string().optional().describe('Filter where domain contains the value (case-insensitive)'),
  "domain.startsWith": zod.string().optional().describe('Filter where domain starts with the value (case-sensitive)'),
  "domain.istartswith": zod.string().optional().describe('Filter where domain starts with the value (case-insensitive)'),
  "title": zod.string().optional().describe('Filter by title (exact match)'),
  "title.contains": zod.string().optional().describe('Filter where title contains the value (case-sensitive)'),
  "title.icontains": zod.string().optional().describe('Filter where title contains the value (case-insensitive)'),
  "title.startsWith": zod.string().optional().describe('Filter where title starts with the value (case-sensitive)'),
  "title.istartswith": zod.string().optional().describe('Filter where title starts with the value (case-insensitive)'),
  "slug": zod.string().optional().describe('Filter by slug (exact match)'),
  "slug.contains": zod.string().optional().describe('Filter where slug contains the value (case-sensitive)'),
  "slug.icontains": zod.string().optional().describe('Filter where slug contains the value (case-insensitive)'),
  "slug.startsWith": zod.string().optional().describe('Filter where slug starts with the value (case-sensitive)'),
  "slug.istartswith": zod.string().optional().describe('Filter where slug starts with the value (case-insensitive)'),
  "description": zod.string().optional().describe('Filter by description (exact match)'),
  "description.contains": zod.string().optional().describe('Filter where description contains the value (case-sensitive)'),
  "description.icontains": zod.string().optional().describe('Filter where description contains the value (case-insensitive)'),
  "description.startsWith": zod.string().optional().describe('Filter where description starts with the value (case-sensitive)'),
  "description.istartswith": zod.string().optional().describe('Filter where description starts with the value (case-insensitive)'),
  "tags": zod.string().optional().describe('Filter by tags (exact match)'),
  "tags.contains": zod.string().optional().describe('Filter where tags contains the value (case-sensitive)'),
  "tags.icontains": zod.string().optional().describe('Filter where tags contains the value (case-insensitive)'),
  "tags.startsWith": zod.string().optional().describe('Filter where tags starts with the value (case-sensitive)'),
  "tags.istartswith": zod.string().optional().describe('Filter where tags starts with the value (case-insensitive)'),
  "type": zod.string().optional().describe('Filter by type (exact match)'),
  "type.contains": zod.string().optional().describe('Filter where type contains the value (case-sensitive)'),
  "type.icontains": zod.string().optional().describe('Filter where type contains the value (case-insensitive)'),
  "type.startsWith": zod.string().optional().describe('Filter where type starts with the value (case-sensitive)'),
  "type.istartswith": zod.string().optional().describe('Filter where type starts with the value (case-insensitive)'),
  "status": zod.string().optional().describe('Filter by status (exact match)'),
  "status.contains": zod.string().optional().describe('Filter where status contains the value (case-sensitive)'),
  "status.icontains": zod.string().optional().describe('Filter where status contains the value (case-insensitive)'),
  "status.startsWith": zod.string().optional().describe('Filter where status starts with the value (case-sensitive)'),
  "status.istartswith": zod.string().optional().describe('Filter where status starts with the value (case-insensitive)'),
  "authorId": zod.string().optional().describe('Filter by authorId'),
  "categories": zod.string().optional().describe('Filter by categories'),
  "createdAt": zod.string().optional().describe('Filter by createdAt (exact match, ISO date string for dates)'),
  "createdAt.gt": zod.string().optional().describe('Filter where createdAt is greater than'),
  "createdAt.gte": zod.string().optional().describe('Filter where createdAt is greater than or equal'),
  "createdAt.lt": zod.string().optional().describe('Filter where createdAt is less than'),
  "createdAt.lte": zod.string().optional().describe('Filter where createdAt is less than or equal'),
  "updatedAt": zod.string().optional().describe('Filter by updatedAt (exact match, ISO date string for dates)'),
  "updatedAt.gt": zod.string().optional().describe('Filter where updatedAt is greater than'),
  "updatedAt.gte": zod.string().optional().describe('Filter where updatedAt is greater than or equal'),
  "updatedAt.lt": zod.string().optional().describe('Filter where updatedAt is less than'),
  "updatedAt.lte": zod.string().optional().describe('Filter where updatedAt is less than or equal')
})

export const postsQueryControllerFindAllResponseItemsItemProjectIdMin = 24;
export const postsQueryControllerFindAllResponseItemsItemProjectIdMax = 24;

export const postsQueryControllerFindAllResponseItemsItemDomainMax = 30;

export const postsQueryControllerFindAllResponseItemsItemTitleMin = 5;
export const postsQueryControllerFindAllResponseItemsItemTitleMax = 120;

export const postsQueryControllerFindAllResponseItemsItemSlugMin = 5;
export const postsQueryControllerFindAllResponseItemsItemSlugMax = 120;

export const postsQueryControllerFindAllResponseItemsItemDescriptionMin = 10;
export const postsQueryControllerFindAllResponseItemsItemDescriptionMax = 500;

export const postsQueryControllerFindAllResponseItemsItemIdMin = 24;
export const postsQueryControllerFindAllResponseItemsItemIdMax = 24;

export const postsQueryControllerFindAllResponseItemsItemAuthorIdMin = 24;
export const postsQueryControllerFindAllResponseItemsItemAuthorIdMax = 24;

export const postsQueryControllerFindAllResponseItemsItemFilesItemLocationTypeDefault = "Point";export const postsQueryControllerFindAllResponseItemsItemFilesItemIdMin = 24;
export const postsQueryControllerFindAllResponseItemsItemFilesItemIdMax = 24;

export const postsQueryControllerFindAllResponseItemsItemAuthorIdMinOne = 24;
export const postsQueryControllerFindAllResponseItemsItemAuthorIdMaxOne = 24;



export const postsQueryControllerFindAllResponse = zod.object({
  "items": zod.array(zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsQueryControllerFindAllResponseItemsItemProjectIdMin).max(postsQueryControllerFindAllResponseItemsItemProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsQueryControllerFindAllResponseItemsItemDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsQueryControllerFindAllResponseItemsItemTitleMin).max(postsQueryControllerFindAllResponseItemsItemTitleMax),
  "slug": zod.string().min(postsQueryControllerFindAllResponseItemsItemSlugMin).max(postsQueryControllerFindAllResponseItemsItemSlugMax),
  "description": zod.string().min(postsQueryControllerFindAllResponseItemsItemDescriptionMin).max(postsQueryControllerFindAllResponseItemsItemDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsQueryControllerFindAllResponseItemsItemIdMin).max(postsQueryControllerFindAllResponseItemsItemIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsQueryControllerFindAllResponseItemsItemAuthorIdMin).max(postsQueryControllerFindAllResponseItemsItemAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsQueryControllerFindAllResponseItemsItemFilesItemIdMin).max(postsQueryControllerFindAllResponseItemsItemFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsQueryControllerFindAllResponseItemsItemAuthorIdMinOne).max(postsQueryControllerFindAllResponseItemsItemAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


/**
 * @summary Create a new post
 */
export const postsControllerCreateBodyDomainMax = 30;

export const postsControllerCreateBodyTitleMin = 5;
export const postsControllerCreateBodyTitleMax = 120;

export const postsControllerCreateBodySlugMin = 5;
export const postsControllerCreateBodySlugMax = 120;

export const postsControllerCreateBodyDescriptionMin = 10;
export const postsControllerCreateBodyDescriptionMax = 500;



export const postsControllerCreateBody = zod.object({
  "domain": zod.string().max(postsControllerCreateBodyDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "categories": zod.array(zod.string()),
  "title": zod.string().min(postsControllerCreateBodyTitleMin).max(postsControllerCreateBodyTitleMax),
  "slug": zod.string().min(postsControllerCreateBodySlugMin).max(postsControllerCreateBodySlugMax),
  "description": zod.string().min(postsControllerCreateBodyDescriptionMin).max(postsControllerCreateBodyDescriptionMax).optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional()
})


/**
 * @summary Get published posts for sitemap generation
 */
export const postsQueryControllerFindSitemapQueryParams = zod.object({
  "limit": zod.number().optional().describe('Number of items to return (1-100, default: 20)'),
  "after": zod.string().optional().describe('Cursor token for next page (forward pagination)'),
  "before": zod.string().optional().describe('Cursor token for previous page (backward pagination)'),
  "sort": zod.enum(['title', 'slug', 'createdAt', 'updatedAt', '-title', '-slug', '-createdAt', '-updatedAt']).optional().describe('Sort field with optional \'-\' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt'),
  "projectId": zod.string().optional().describe('Filter by projectId'),
  "domain": zod.string().optional().describe('Filter by domain (exact match)'),
  "domain.contains": zod.string().optional().describe('Filter where domain contains the value (case-sensitive)'),
  "domain.icontains": zod.string().optional().describe('Filter where domain contains the value (case-insensitive)'),
  "domain.startsWith": zod.string().optional().describe('Filter where domain starts with the value (case-sensitive)'),
  "domain.istartswith": zod.string().optional().describe('Filter where domain starts with the value (case-insensitive)'),
  "title": zod.string().optional().describe('Filter by title (exact match)'),
  "title.contains": zod.string().optional().describe('Filter where title contains the value (case-sensitive)'),
  "title.icontains": zod.string().optional().describe('Filter where title contains the value (case-insensitive)'),
  "title.startsWith": zod.string().optional().describe('Filter where title starts with the value (case-sensitive)'),
  "title.istartswith": zod.string().optional().describe('Filter where title starts with the value (case-insensitive)'),
  "slug": zod.string().optional().describe('Filter by slug (exact match)'),
  "slug.contains": zod.string().optional().describe('Filter where slug contains the value (case-sensitive)'),
  "slug.icontains": zod.string().optional().describe('Filter where slug contains the value (case-insensitive)'),
  "slug.startsWith": zod.string().optional().describe('Filter where slug starts with the value (case-sensitive)'),
  "slug.istartswith": zod.string().optional().describe('Filter where slug starts with the value (case-insensitive)'),
  "description": zod.string().optional().describe('Filter by description (exact match)'),
  "description.contains": zod.string().optional().describe('Filter where description contains the value (case-sensitive)'),
  "description.icontains": zod.string().optional().describe('Filter where description contains the value (case-insensitive)'),
  "description.startsWith": zod.string().optional().describe('Filter where description starts with the value (case-sensitive)'),
  "description.istartswith": zod.string().optional().describe('Filter where description starts with the value (case-insensitive)'),
  "tags": zod.string().optional().describe('Filter by tags (exact match)'),
  "tags.contains": zod.string().optional().describe('Filter where tags contains the value (case-sensitive)'),
  "tags.icontains": zod.string().optional().describe('Filter where tags contains the value (case-insensitive)'),
  "tags.startsWith": zod.string().optional().describe('Filter where tags starts with the value (case-sensitive)'),
  "tags.istartswith": zod.string().optional().describe('Filter where tags starts with the value (case-insensitive)'),
  "type": zod.string().optional().describe('Filter by type (exact match)'),
  "type.contains": zod.string().optional().describe('Filter where type contains the value (case-sensitive)'),
  "type.icontains": zod.string().optional().describe('Filter where type contains the value (case-insensitive)'),
  "type.startsWith": zod.string().optional().describe('Filter where type starts with the value (case-sensitive)'),
  "type.istartswith": zod.string().optional().describe('Filter where type starts with the value (case-insensitive)'),
  "status": zod.string().optional().describe('Filter by status (exact match)'),
  "status.contains": zod.string().optional().describe('Filter where status contains the value (case-sensitive)'),
  "status.icontains": zod.string().optional().describe('Filter where status contains the value (case-insensitive)'),
  "status.startsWith": zod.string().optional().describe('Filter where status starts with the value (case-sensitive)'),
  "status.istartswith": zod.string().optional().describe('Filter where status starts with the value (case-insensitive)'),
  "authorId": zod.string().optional().describe('Filter by authorId'),
  "categories": zod.string().optional().describe('Filter by categories'),
  "createdAt": zod.string().optional().describe('Filter by createdAt (exact match, ISO date string for dates)'),
  "createdAt.gt": zod.string().optional().describe('Filter where createdAt is greater than'),
  "createdAt.gte": zod.string().optional().describe('Filter where createdAt is greater than or equal'),
  "createdAt.lt": zod.string().optional().describe('Filter where createdAt is less than'),
  "createdAt.lte": zod.string().optional().describe('Filter where createdAt is less than or equal'),
  "updatedAt": zod.string().optional().describe('Filter by updatedAt (exact match, ISO date string for dates)'),
  "updatedAt.gt": zod.string().optional().describe('Filter where updatedAt is greater than'),
  "updatedAt.gte": zod.string().optional().describe('Filter where updatedAt is greater than or equal'),
  "updatedAt.lt": zod.string().optional().describe('Filter where updatedAt is less than'),
  "updatedAt.lte": zod.string().optional().describe('Filter where updatedAt is less than or equal')
})

export const postsQueryControllerFindSitemapResponse = zod.object({
  "items": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "domain": zod.string().describe('Domain label for multi-site support'),
  "slug": zod.string().describe('Post slug for URL construction'),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}).describe('Last modification date for sitemap lastmod')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


/**
 * @summary Upload file to post
 */
export const postsFileControllerUploadFileParams = zod.object({
  "post": zod.string()
})

export const postsFileControllerUploadFileBody = zod.object({
  "file": zod.instanceof(File).describe('The file to upload'),
  "exif": zod.string().optional().describe('EXIF metadata as JSON string')
})

export const postsFileControllerUploadFileResponse = zod.object({
  "status": zod.boolean().describe('Response status as boolean')
})


/**
 * @summary Update file metadata
 */
export const postsFileControllerUpdateFileParams = zod.object({
  "post": zod.string(),
  "id": zod.string()
})

export const postsFileControllerUpdateFileBodyLocationTypeDefault = "Point";

export const postsFileControllerUpdateFileBody = zod.object({
  "altText": zod.string(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional()
})

export const postsFileControllerUpdateFileResponse = zod.object({
  "id": zod.string().describe('Response id as string')
})


/**
 * @summary Delete file from post
 */
export const postsFileControllerDeleteFileParams = zod.object({
  "post": zod.string(),
  "id": zod.string()
})

export const postsFileControllerDeleteFileResponse = zod.object({
  "status": zod.boolean().describe('Response status as boolean')
})


/**
 * @summary Get tag cloud
 */
export const postsAnalyticsControllerGetTagCloudResponseItem = zod.object({
  "name": zod.string(),
  "usage": zod.number()
})
export const postsAnalyticsControllerGetTagCloudResponse = zod.array(postsAnalyticsControllerGetTagCloudResponseItem)


/**
 * @summary Get tag cloud by domain
 */
export const postsAnalyticsControllerGetTagCloudByDomainParams = zod.object({
  "domain": zod.string()
})

export const postsAnalyticsControllerGetTagCloudByDomainResponseItem = zod.object({
  "name": zod.string(),
  "usage": zod.number()
})
export const postsAnalyticsControllerGetTagCloudByDomainResponse = zod.array(postsAnalyticsControllerGetTagCloudByDomainResponseItem)


/**
 * @summary Get tag cloud by category
 */
export const postsAnalyticsControllerGetTagCloudByCategoryParams = zod.object({
  "category": zod.string()
})

export const postsAnalyticsControllerGetTagCloudByCategoryResponseItem = zod.object({
  "name": zod.string(),
  "usage": zod.number()
})
export const postsAnalyticsControllerGetTagCloudByCategoryResponse = zod.array(postsAnalyticsControllerGetTagCloudByCategoryResponseItem)


/**
 * @summary Get tag cloud by category and domain
 */
export const postsAnalyticsControllerGetTagCloudByCategoryAndDomainParams = zod.object({
  "category": zod.string(),
  "domain": zod.string()
})

export const postsAnalyticsControllerGetTagCloudByCategoryAndDomainResponseItem = zod.object({
  "name": zod.string(),
  "usage": zod.number()
})
export const postsAnalyticsControllerGetTagCloudByCategoryAndDomainResponse = zod.array(postsAnalyticsControllerGetTagCloudByCategoryAndDomainResponseItem)


/**
 * @summary Get posts statistics
 */
export const postsAnalyticsControllerGetPostStatisticsResponse = zod.object({
  "total": zod.number().optional(),
  "published": zod.number().optional(),
  "draft": zod.number().optional(),
  "byType": zod.array(zod.object({
  "type": zod.string().optional(),
  "count": zod.number().optional()
})).optional(),
  "byStatus": zod.array(zod.object({
  "status": zod.string().optional(),
  "count": zod.number().optional()
})).optional()
})


/**
 * @summary Get popular tags
 */
export const postsAnalyticsControllerGetPopularTagsResponseItem = zod.object({
  "name": zod.string(),
  "usage": zod.number()
})
export const postsAnalyticsControllerGetPopularTagsResponse = zod.array(postsAnalyticsControllerGetPopularTagsResponseItem)


/**
 * @summary Create a GPT-generated post
 */
export const gptPostControllerCreateGptPostBodyDomainMax = 30;

export const gptPostControllerCreateGptPostBodyTitleMin = 5;
export const gptPostControllerCreateGptPostBodyTitleMax = 120;

export const gptPostControllerCreateGptPostBodySlugMin = 5;
export const gptPostControllerCreateGptPostBodySlugMax = 120;

export const gptPostControllerCreateGptPostBodyDescriptionMin = 10;
export const gptPostControllerCreateGptPostBodyDescriptionMax = 500;



export const gptPostControllerCreateGptPostBody = zod.object({
  "domain": zod.string().max(gptPostControllerCreateGptPostBodyDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "categories": zod.array(zod.string()),
  "title": zod.string().min(gptPostControllerCreateGptPostBodyTitleMin).max(gptPostControllerCreateGptPostBodyTitleMax),
  "slug": zod.string().min(gptPostControllerCreateGptPostBodySlugMin).max(gptPostControllerCreateGptPostBodySlugMax),
  "description": zod.string().min(gptPostControllerCreateGptPostBodyDescriptionMin).max(gptPostControllerCreateGptPostBodyDescriptionMax).optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional()
})


/**
 * @summary Search posts for GPT context
 */
export const gptPostControllerSearchPostsQueryParams = zod.object({
  "q": zod.string().describe('Search query for finding relevant posts')
})

export const gptPostControllerSearchPostsResponseProjectIdMin = 24;
export const gptPostControllerSearchPostsResponseProjectIdMax = 24;

export const gptPostControllerSearchPostsResponseDomainMax = 30;

export const gptPostControllerSearchPostsResponseTitleMin = 5;
export const gptPostControllerSearchPostsResponseTitleMax = 120;

export const gptPostControllerSearchPostsResponseSlugMin = 5;
export const gptPostControllerSearchPostsResponseSlugMax = 120;

export const gptPostControllerSearchPostsResponseDescriptionMin = 10;
export const gptPostControllerSearchPostsResponseDescriptionMax = 500;

export const gptPostControllerSearchPostsResponseIdMin = 24;
export const gptPostControllerSearchPostsResponseIdMax = 24;

export const gptPostControllerSearchPostsResponseAuthorIdMin = 24;
export const gptPostControllerSearchPostsResponseAuthorIdMax = 24;

export const gptPostControllerSearchPostsResponseFilesItemLocationTypeDefault = "Point";export const gptPostControllerSearchPostsResponseFilesItemIdMin = 24;
export const gptPostControllerSearchPostsResponseFilesItemIdMax = 24;

export const gptPostControllerSearchPostsResponseAuthorIdMinOne = 24;
export const gptPostControllerSearchPostsResponseAuthorIdMaxOne = 24;



export const gptPostControllerSearchPostsResponseItem = zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(gptPostControllerSearchPostsResponseProjectIdMin).max(gptPostControllerSearchPostsResponseProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(gptPostControllerSearchPostsResponseDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(gptPostControllerSearchPostsResponseTitleMin).max(gptPostControllerSearchPostsResponseTitleMax),
  "slug": zod.string().min(gptPostControllerSearchPostsResponseSlugMin).max(gptPostControllerSearchPostsResponseSlugMax),
  "description": zod.string().min(gptPostControllerSearchPostsResponseDescriptionMin).max(gptPostControllerSearchPostsResponseDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(gptPostControllerSearchPostsResponseIdMin).max(gptPostControllerSearchPostsResponseIdMax).describe('The unique id'),
  "authorId": zod.string().min(gptPostControllerSearchPostsResponseAuthorIdMin).max(gptPostControllerSearchPostsResponseAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(gptPostControllerSearchPostsResponseFilesItemIdMin).max(gptPostControllerSearchPostsResponseFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(gptPostControllerSearchPostsResponseAuthorIdMinOne).max(gptPostControllerSearchPostsResponseAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})
export const gptPostControllerSearchPostsResponse = zod.array(gptPostControllerSearchPostsResponseItem)


/**
 * @summary Get post by ID for GPT processing
 */
export const gptPostControllerFindPostByIdParams = zod.object({
  "id": zod.string()
})

export const gptPostControllerFindPostByIdResponseProjectIdMin = 24;
export const gptPostControllerFindPostByIdResponseProjectIdMax = 24;

export const gptPostControllerFindPostByIdResponseDomainMax = 30;

export const gptPostControllerFindPostByIdResponseTitleMin = 5;
export const gptPostControllerFindPostByIdResponseTitleMax = 120;

export const gptPostControllerFindPostByIdResponseSlugMin = 5;
export const gptPostControllerFindPostByIdResponseSlugMax = 120;

export const gptPostControllerFindPostByIdResponseDescriptionMin = 10;
export const gptPostControllerFindPostByIdResponseDescriptionMax = 500;

export const gptPostControllerFindPostByIdResponseIdMin = 24;
export const gptPostControllerFindPostByIdResponseIdMax = 24;

export const gptPostControllerFindPostByIdResponseAuthorIdMin = 24;
export const gptPostControllerFindPostByIdResponseAuthorIdMax = 24;

export const gptPostControllerFindPostByIdResponseFilesItemLocationTypeDefault = "Point";export const gptPostControllerFindPostByIdResponseFilesItemIdMin = 24;
export const gptPostControllerFindPostByIdResponseFilesItemIdMax = 24;

export const gptPostControllerFindPostByIdResponseAuthorIdMinOne = 24;
export const gptPostControllerFindPostByIdResponseAuthorIdMaxOne = 24;



export const gptPostControllerFindPostByIdResponse = zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(gptPostControllerFindPostByIdResponseProjectIdMin).max(gptPostControllerFindPostByIdResponseProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(gptPostControllerFindPostByIdResponseDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(gptPostControllerFindPostByIdResponseTitleMin).max(gptPostControllerFindPostByIdResponseTitleMax),
  "slug": zod.string().min(gptPostControllerFindPostByIdResponseSlugMin).max(gptPostControllerFindPostByIdResponseSlugMax),
  "description": zod.string().min(gptPostControllerFindPostByIdResponseDescriptionMin).max(gptPostControllerFindPostByIdResponseDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(gptPostControllerFindPostByIdResponseIdMin).max(gptPostControllerFindPostByIdResponseIdMax).describe('The unique id'),
  "authorId": zod.string().min(gptPostControllerFindPostByIdResponseAuthorIdMin).max(gptPostControllerFindPostByIdResponseAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(gptPostControllerFindPostByIdResponseFilesItemIdMin).max(gptPostControllerFindPostByIdResponseFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(gptPostControllerFindPostByIdResponseAuthorIdMinOne).max(gptPostControllerFindPostByIdResponseAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})


/**
 * @summary Update post with GPT-generated content
 */
export const gptPostControllerUpdateGptPostParams = zod.object({
  "id": zod.string()
})

export const gptPostControllerUpdateGptPostBodyDomainMax = 30;

export const gptPostControllerUpdateGptPostBodyTitleMin = 5;
export const gptPostControllerUpdateGptPostBodyTitleMax = 120;

export const gptPostControllerUpdateGptPostBodySlugMin = 5;
export const gptPostControllerUpdateGptPostBodySlugMax = 120;

export const gptPostControllerUpdateGptPostBodyDescriptionMin = 10;
export const gptPostControllerUpdateGptPostBodyDescriptionMax = 500;

export const gptPostControllerUpdateGptPostBodyFilesItemLocationTypeDefault = "Point";export const gptPostControllerUpdateGptPostBodyFilesItemIdMin = 24;
export const gptPostControllerUpdateGptPostBodyFilesItemIdMax = 24;



export const gptPostControllerUpdateGptPostBody = zod.object({
  "domain": zod.string().max(gptPostControllerUpdateGptPostBodyDomainMax).optional().describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(gptPostControllerUpdateGptPostBodyTitleMin).max(gptPostControllerUpdateGptPostBodyTitleMax).optional(),
  "slug": zod.string().min(gptPostControllerUpdateGptPostBodySlugMin).max(gptPostControllerUpdateGptPostBodySlugMax).optional(),
  "description": zod.string().min(gptPostControllerUpdateGptPostBodyDescriptionMin).max(gptPostControllerUpdateGptPostBodyDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "categories": zod.array(zod.string()),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "id": zod.string().min(gptPostControllerUpdateGptPostBodyFilesItemIdMin).max(gptPostControllerUpdateGptPostBodyFilesItemIdMax).describe('The unique id')
})).optional()
})

export const gptPostControllerUpdateGptPostResponse = zod.object({
  "id": zod.string().describe('Response id as string')
})


/**
 * Process and attach files from OpenAI Assistant API responses
 * @summary Upload files from OpenAI file references
 */
export const gptPostControllerUploadOpenAIFilesParams = zod.object({
  "id": zod.string().describe('Post ID to attach files to')
})

export const gptPostControllerUploadOpenAIFilesBodyFilesItemMimeTypeDefault = "image/png";

export const gptPostControllerUploadOpenAIFilesBody = zod.object({
  "files": zod.array(zod.object({
  "name": zod.string().describe('The name of the file'),
  "id": zod.string().describe('A stable identifier for the file'),
  "mime_type": zod.string().describe('The mime type of the file'),
  "download_link": zod.string().describe('The URL to fetch the file which is valid for five minutes')
})).describe('Array of OpenAI file references')
})

export const gptPostControllerUploadOpenAIFilesResponse = zod.object({
  "status": zod.boolean().describe('Response status as boolean')
})


/**
 * @summary Update file metadata for GPT-uploaded files
 */
export const gptPostControllerUpdatePostFileParams = zod.object({
  "id": zod.string(),
  "fileId": zod.string()
})

export const gptPostControllerUpdatePostFileBodyLocationTypeDefault = "Point";

export const gptPostControllerUpdatePostFileBody = zod.object({
  "altText": zod.string(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional()
})

export const gptPostControllerUpdatePostFileResponse = zod.object({
  "id": zod.string().describe('Response id as string')
})


/**
 * @summary Get post by ID
 */
export const postsControllerFindOnePathIdMin = 24;
export const postsControllerFindOnePathIdMax = 24;



export const postsControllerFindOneParams = zod.object({
  "id": zod.string().min(postsControllerFindOnePathIdMin).max(postsControllerFindOnePathIdMax).describe('MongoDB ObjectId')
})

export const postsControllerFindOneResponseProjectIdMin = 24;
export const postsControllerFindOneResponseProjectIdMax = 24;

export const postsControllerFindOneResponseDomainMax = 30;

export const postsControllerFindOneResponseTitleMin = 5;
export const postsControllerFindOneResponseTitleMax = 120;

export const postsControllerFindOneResponseSlugMin = 5;
export const postsControllerFindOneResponseSlugMax = 120;

export const postsControllerFindOneResponseDescriptionMin = 10;
export const postsControllerFindOneResponseDescriptionMax = 500;

export const postsControllerFindOneResponseIdMin = 24;
export const postsControllerFindOneResponseIdMax = 24;

export const postsControllerFindOneResponseAuthorIdMin = 24;
export const postsControllerFindOneResponseAuthorIdMax = 24;

export const postsControllerFindOneResponseFilesItemLocationTypeDefault = "Point";export const postsControllerFindOneResponseFilesItemIdMin = 24;
export const postsControllerFindOneResponseFilesItemIdMax = 24;

export const postsControllerFindOneResponseAuthorIdMinOne = 24;
export const postsControllerFindOneResponseAuthorIdMaxOne = 24;



export const postsControllerFindOneResponse = zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsControllerFindOneResponseProjectIdMin).max(postsControllerFindOneResponseProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsControllerFindOneResponseDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerFindOneResponseTitleMin).max(postsControllerFindOneResponseTitleMax),
  "slug": zod.string().min(postsControllerFindOneResponseSlugMin).max(postsControllerFindOneResponseSlugMax),
  "description": zod.string().min(postsControllerFindOneResponseDescriptionMin).max(postsControllerFindOneResponseDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsControllerFindOneResponseIdMin).max(postsControllerFindOneResponseIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsControllerFindOneResponseAuthorIdMin).max(postsControllerFindOneResponseAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsControllerFindOneResponseFilesItemIdMin).max(postsControllerFindOneResponseFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsControllerFindOneResponseAuthorIdMinOne).max(postsControllerFindOneResponseAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})


/**
 * @summary Update post by ID
 */
export const postsControllerUpdatePathIdMin = 24;
export const postsControllerUpdatePathIdMax = 24;



export const postsControllerUpdateParams = zod.object({
  "id": zod.string().min(postsControllerUpdatePathIdMin).max(postsControllerUpdatePathIdMax).describe('MongoDB ObjectId')
})

export const postsControllerUpdateBodyDomainMax = 30;

export const postsControllerUpdateBodyTitleMin = 5;
export const postsControllerUpdateBodyTitleMax = 120;

export const postsControllerUpdateBodySlugMin = 5;
export const postsControllerUpdateBodySlugMax = 120;

export const postsControllerUpdateBodyDescriptionMin = 10;
export const postsControllerUpdateBodyDescriptionMax = 500;

export const postsControllerUpdateBodyFilesItemLocationTypeDefault = "Point";export const postsControllerUpdateBodyFilesItemIdMin = 24;
export const postsControllerUpdateBodyFilesItemIdMax = 24;



export const postsControllerUpdateBody = zod.object({
  "domain": zod.string().max(postsControllerUpdateBodyDomainMax).optional().describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerUpdateBodyTitleMin).max(postsControllerUpdateBodyTitleMax).optional(),
  "slug": zod.string().min(postsControllerUpdateBodySlugMin).max(postsControllerUpdateBodySlugMax).optional(),
  "description": zod.string().min(postsControllerUpdateBodyDescriptionMin).max(postsControllerUpdateBodyDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "categories": zod.array(zod.string()),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "id": zod.string().min(postsControllerUpdateBodyFilesItemIdMin).max(postsControllerUpdateBodyFilesItemIdMax).describe('The unique id')
})).optional()
})

export const postsControllerUpdateResponse = zod.object({
  "id": zod.string().describe('Response id as string')
})


/**
 * @summary Delete post by ID
 */
export const postsControllerDeletePathIdMin = 24;
export const postsControllerDeletePathIdMax = 24;



export const postsControllerDeleteParams = zod.object({
  "id": zod.string().min(postsControllerDeletePathIdMin).max(postsControllerDeletePathIdMax).describe('MongoDB ObjectId')
})

export const postsControllerDeleteResponse = zod.object({
  "id": zod.string().describe('Response id as string')
})


/**
 * @summary Get post by slug and domain
 */
export const postsControllerFindOneBySlugParams = zod.object({
  "slug": zod.string(),
  "domain": zod.string()
})

export const postsControllerFindOneBySlugResponseProjectIdMin = 24;
export const postsControllerFindOneBySlugResponseProjectIdMax = 24;

export const postsControllerFindOneBySlugResponseDomainMax = 30;

export const postsControllerFindOneBySlugResponseTitleMin = 5;
export const postsControllerFindOneBySlugResponseTitleMax = 120;

export const postsControllerFindOneBySlugResponseSlugMin = 5;
export const postsControllerFindOneBySlugResponseSlugMax = 120;

export const postsControllerFindOneBySlugResponseDescriptionMin = 10;
export const postsControllerFindOneBySlugResponseDescriptionMax = 500;

export const postsControllerFindOneBySlugResponseIdMin = 24;
export const postsControllerFindOneBySlugResponseIdMax = 24;

export const postsControllerFindOneBySlugResponseAuthorIdMin = 24;
export const postsControllerFindOneBySlugResponseAuthorIdMax = 24;

export const postsControllerFindOneBySlugResponseFilesItemLocationTypeDefault = "Point";export const postsControllerFindOneBySlugResponseFilesItemIdMin = 24;
export const postsControllerFindOneBySlugResponseFilesItemIdMax = 24;

export const postsControllerFindOneBySlugResponseAuthorIdMinOne = 24;
export const postsControllerFindOneBySlugResponseAuthorIdMaxOne = 24;



export const postsControllerFindOneBySlugResponse = zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsControllerFindOneBySlugResponseProjectIdMin).max(postsControllerFindOneBySlugResponseProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsControllerFindOneBySlugResponseDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerFindOneBySlugResponseTitleMin).max(postsControllerFindOneBySlugResponseTitleMax),
  "slug": zod.string().min(postsControllerFindOneBySlugResponseSlugMin).max(postsControllerFindOneBySlugResponseSlugMax),
  "description": zod.string().min(postsControllerFindOneBySlugResponseDescriptionMin).max(postsControllerFindOneBySlugResponseDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsControllerFindOneBySlugResponseIdMin).max(postsControllerFindOneBySlugResponseIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsControllerFindOneBySlugResponseAuthorIdMin).max(postsControllerFindOneBySlugResponseAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsControllerFindOneBySlugResponseFilesItemIdMin).max(postsControllerFindOneBySlugResponseFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsControllerFindOneBySlugResponseAuthorIdMinOne).max(postsControllerFindOneBySlugResponseAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})


/**
 * @summary Get posts by domain with keyset pagination
 */
export const postsControllerFindByDomainParams = zod.object({
  "domain": zod.string()
})

export const postsControllerFindByDomainQueryParams = zod.object({
  "limit": zod.number().optional().describe('Number of items to return (1-100, default: 20)'),
  "after": zod.string().optional().describe('Cursor token for next page (forward pagination)'),
  "before": zod.string().optional().describe('Cursor token for previous page (backward pagination)'),
  "sort": zod.enum(['title', 'slug', 'createdAt', 'updatedAt', '-title', '-slug', '-createdAt', '-updatedAt']).optional().describe('Sort field with optional \'-\' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt'),
  "domain": zod.string().optional().describe('Filter by domain (exact match)'),
  "domain.contains": zod.string().optional().describe('Filter where domain contains the value (case-sensitive)'),
  "domain.icontains": zod.string().optional().describe('Filter where domain contains the value (case-insensitive)'),
  "domain.startsWith": zod.string().optional().describe('Filter where domain starts with the value (case-sensitive)'),
  "domain.istartswith": zod.string().optional().describe('Filter where domain starts with the value (case-insensitive)'),
  "title": zod.string().optional().describe('Filter by title (exact match)'),
  "title.contains": zod.string().optional().describe('Filter where title contains the value (case-sensitive)'),
  "title.icontains": zod.string().optional().describe('Filter where title contains the value (case-insensitive)'),
  "title.startsWith": zod.string().optional().describe('Filter where title starts with the value (case-sensitive)'),
  "title.istartswith": zod.string().optional().describe('Filter where title starts with the value (case-insensitive)'),
  "slug": zod.string().optional().describe('Filter by slug (exact match)'),
  "slug.contains": zod.string().optional().describe('Filter where slug contains the value (case-sensitive)'),
  "slug.icontains": zod.string().optional().describe('Filter where slug contains the value (case-insensitive)'),
  "slug.startsWith": zod.string().optional().describe('Filter where slug starts with the value (case-sensitive)'),
  "slug.istartswith": zod.string().optional().describe('Filter where slug starts with the value (case-insensitive)'),
  "description": zod.string().optional().describe('Filter by description (exact match)'),
  "description.contains": zod.string().optional().describe('Filter where description contains the value (case-sensitive)'),
  "description.icontains": zod.string().optional().describe('Filter where description contains the value (case-insensitive)'),
  "description.startsWith": zod.string().optional().describe('Filter where description starts with the value (case-sensitive)'),
  "description.istartswith": zod.string().optional().describe('Filter where description starts with the value (case-insensitive)'),
  "tags": zod.string().optional().describe('Filter by tags (exact match)'),
  "tags.contains": zod.string().optional().describe('Filter where tags contains the value (case-sensitive)'),
  "tags.icontains": zod.string().optional().describe('Filter where tags contains the value (case-insensitive)'),
  "tags.startsWith": zod.string().optional().describe('Filter where tags starts with the value (case-sensitive)'),
  "tags.istartswith": zod.string().optional().describe('Filter where tags starts with the value (case-insensitive)'),
  "type": zod.string().optional().describe('Filter by type (exact match)'),
  "type.contains": zod.string().optional().describe('Filter where type contains the value (case-sensitive)'),
  "type.icontains": zod.string().optional().describe('Filter where type contains the value (case-insensitive)'),
  "type.startsWith": zod.string().optional().describe('Filter where type starts with the value (case-sensitive)'),
  "type.istartswith": zod.string().optional().describe('Filter where type starts with the value (case-insensitive)'),
  "status": zod.string().optional().describe('Filter by status (exact match)'),
  "status.contains": zod.string().optional().describe('Filter where status contains the value (case-sensitive)'),
  "status.icontains": zod.string().optional().describe('Filter where status contains the value (case-insensitive)'),
  "status.startsWith": zod.string().optional().describe('Filter where status starts with the value (case-sensitive)'),
  "status.istartswith": zod.string().optional().describe('Filter where status starts with the value (case-insensitive)'),
  "authorId": zod.string().optional().describe('Filter by authorId'),
  "categories": zod.string().optional().describe('Filter by categories'),
  "createdAt": zod.string().optional().describe('Filter by createdAt (exact match, ISO date string for dates)'),
  "createdAt.gt": zod.string().optional().describe('Filter where createdAt is greater than'),
  "createdAt.gte": zod.string().optional().describe('Filter where createdAt is greater than or equal'),
  "createdAt.lt": zod.string().optional().describe('Filter where createdAt is less than'),
  "createdAt.lte": zod.string().optional().describe('Filter where createdAt is less than or equal'),
  "updatedAt": zod.string().optional().describe('Filter by updatedAt (exact match, ISO date string for dates)'),
  "updatedAt.gt": zod.string().optional().describe('Filter where updatedAt is greater than'),
  "updatedAt.gte": zod.string().optional().describe('Filter where updatedAt is greater than or equal'),
  "updatedAt.lt": zod.string().optional().describe('Filter where updatedAt is less than'),
  "updatedAt.lte": zod.string().optional().describe('Filter where updatedAt is less than or equal')
})

export const postsControllerFindByDomainResponseItemsItemProjectIdMin = 24;
export const postsControllerFindByDomainResponseItemsItemProjectIdMax = 24;

export const postsControllerFindByDomainResponseItemsItemDomainMax = 30;

export const postsControllerFindByDomainResponseItemsItemTitleMin = 5;
export const postsControllerFindByDomainResponseItemsItemTitleMax = 120;

export const postsControllerFindByDomainResponseItemsItemSlugMin = 5;
export const postsControllerFindByDomainResponseItemsItemSlugMax = 120;

export const postsControllerFindByDomainResponseItemsItemDescriptionMin = 10;
export const postsControllerFindByDomainResponseItemsItemDescriptionMax = 500;

export const postsControllerFindByDomainResponseItemsItemIdMin = 24;
export const postsControllerFindByDomainResponseItemsItemIdMax = 24;

export const postsControllerFindByDomainResponseItemsItemAuthorIdMin = 24;
export const postsControllerFindByDomainResponseItemsItemAuthorIdMax = 24;

export const postsControllerFindByDomainResponseItemsItemFilesItemLocationTypeDefault = "Point";export const postsControllerFindByDomainResponseItemsItemFilesItemIdMin = 24;
export const postsControllerFindByDomainResponseItemsItemFilesItemIdMax = 24;

export const postsControllerFindByDomainResponseItemsItemAuthorIdMinOne = 24;
export const postsControllerFindByDomainResponseItemsItemAuthorIdMaxOne = 24;



export const postsControllerFindByDomainResponse = zod.object({
  "items": zod.array(zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsControllerFindByDomainResponseItemsItemProjectIdMin).max(postsControllerFindByDomainResponseItemsItemProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsControllerFindByDomainResponseItemsItemDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerFindByDomainResponseItemsItemTitleMin).max(postsControllerFindByDomainResponseItemsItemTitleMax),
  "slug": zod.string().min(postsControllerFindByDomainResponseItemsItemSlugMin).max(postsControllerFindByDomainResponseItemsItemSlugMax),
  "description": zod.string().min(postsControllerFindByDomainResponseItemsItemDescriptionMin).max(postsControllerFindByDomainResponseItemsItemDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsControllerFindByDomainResponseItemsItemIdMin).max(postsControllerFindByDomainResponseItemsItemIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsControllerFindByDomainResponseItemsItemAuthorIdMin).max(postsControllerFindByDomainResponseItemsItemAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsControllerFindByDomainResponseItemsItemFilesItemIdMin).max(postsControllerFindByDomainResponseItemsItemFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsControllerFindByDomainResponseItemsItemAuthorIdMinOne).max(postsControllerFindByDomainResponseItemsItemAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


/**
 * @summary Get posts by status with keyset pagination
 */
export const postsControllerFindByStatusParams = zod.object({
  "status": zod.string()
})

export const postsControllerFindByStatusQueryParams = zod.object({
  "limit": zod.number().optional().describe('Number of items to return (1-100, default: 20)'),
  "after": zod.string().optional().describe('Cursor token for next page (forward pagination)'),
  "before": zod.string().optional().describe('Cursor token for previous page (backward pagination)'),
  "sort": zod.enum(['title', 'slug', 'createdAt', 'updatedAt', '-title', '-slug', '-createdAt', '-updatedAt']).optional().describe('Sort field with optional \'-\' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt'),
  "domain": zod.string().optional().describe('Filter by domain (exact match)'),
  "domain.contains": zod.string().optional().describe('Filter where domain contains the value (case-sensitive)'),
  "domain.icontains": zod.string().optional().describe('Filter where domain contains the value (case-insensitive)'),
  "domain.startsWith": zod.string().optional().describe('Filter where domain starts with the value (case-sensitive)'),
  "domain.istartswith": zod.string().optional().describe('Filter where domain starts with the value (case-insensitive)'),
  "title": zod.string().optional().describe('Filter by title (exact match)'),
  "title.contains": zod.string().optional().describe('Filter where title contains the value (case-sensitive)'),
  "title.icontains": zod.string().optional().describe('Filter where title contains the value (case-insensitive)'),
  "title.startsWith": zod.string().optional().describe('Filter where title starts with the value (case-sensitive)'),
  "title.istartswith": zod.string().optional().describe('Filter where title starts with the value (case-insensitive)'),
  "slug": zod.string().optional().describe('Filter by slug (exact match)'),
  "slug.contains": zod.string().optional().describe('Filter where slug contains the value (case-sensitive)'),
  "slug.icontains": zod.string().optional().describe('Filter where slug contains the value (case-insensitive)'),
  "slug.startsWith": zod.string().optional().describe('Filter where slug starts with the value (case-sensitive)'),
  "slug.istartswith": zod.string().optional().describe('Filter where slug starts with the value (case-insensitive)'),
  "description": zod.string().optional().describe('Filter by description (exact match)'),
  "description.contains": zod.string().optional().describe('Filter where description contains the value (case-sensitive)'),
  "description.icontains": zod.string().optional().describe('Filter where description contains the value (case-insensitive)'),
  "description.startsWith": zod.string().optional().describe('Filter where description starts with the value (case-sensitive)'),
  "description.istartswith": zod.string().optional().describe('Filter where description starts with the value (case-insensitive)'),
  "tags": zod.string().optional().describe('Filter by tags (exact match)'),
  "tags.contains": zod.string().optional().describe('Filter where tags contains the value (case-sensitive)'),
  "tags.icontains": zod.string().optional().describe('Filter where tags contains the value (case-insensitive)'),
  "tags.startsWith": zod.string().optional().describe('Filter where tags starts with the value (case-sensitive)'),
  "tags.istartswith": zod.string().optional().describe('Filter where tags starts with the value (case-insensitive)'),
  "type": zod.string().optional().describe('Filter by type (exact match)'),
  "type.contains": zod.string().optional().describe('Filter where type contains the value (case-sensitive)'),
  "type.icontains": zod.string().optional().describe('Filter where type contains the value (case-insensitive)'),
  "type.startsWith": zod.string().optional().describe('Filter where type starts with the value (case-sensitive)'),
  "type.istartswith": zod.string().optional().describe('Filter where type starts with the value (case-insensitive)'),
  "status": zod.string().optional().describe('Filter by status (exact match)'),
  "status.contains": zod.string().optional().describe('Filter where status contains the value (case-sensitive)'),
  "status.icontains": zod.string().optional().describe('Filter where status contains the value (case-insensitive)'),
  "status.startsWith": zod.string().optional().describe('Filter where status starts with the value (case-sensitive)'),
  "status.istartswith": zod.string().optional().describe('Filter where status starts with the value (case-insensitive)'),
  "authorId": zod.string().optional().describe('Filter by authorId'),
  "categories": zod.string().optional().describe('Filter by categories'),
  "createdAt": zod.string().optional().describe('Filter by createdAt (exact match, ISO date string for dates)'),
  "createdAt.gt": zod.string().optional().describe('Filter where createdAt is greater than'),
  "createdAt.gte": zod.string().optional().describe('Filter where createdAt is greater than or equal'),
  "createdAt.lt": zod.string().optional().describe('Filter where createdAt is less than'),
  "createdAt.lte": zod.string().optional().describe('Filter where createdAt is less than or equal'),
  "updatedAt": zod.string().optional().describe('Filter by updatedAt (exact match, ISO date string for dates)'),
  "updatedAt.gt": zod.string().optional().describe('Filter where updatedAt is greater than'),
  "updatedAt.gte": zod.string().optional().describe('Filter where updatedAt is greater than or equal'),
  "updatedAt.lt": zod.string().optional().describe('Filter where updatedAt is less than'),
  "updatedAt.lte": zod.string().optional().describe('Filter where updatedAt is less than or equal')
})

export const postsControllerFindByStatusResponseItemsItemProjectIdMin = 24;
export const postsControllerFindByStatusResponseItemsItemProjectIdMax = 24;

export const postsControllerFindByStatusResponseItemsItemDomainMax = 30;

export const postsControllerFindByStatusResponseItemsItemTitleMin = 5;
export const postsControllerFindByStatusResponseItemsItemTitleMax = 120;

export const postsControllerFindByStatusResponseItemsItemSlugMin = 5;
export const postsControllerFindByStatusResponseItemsItemSlugMax = 120;

export const postsControllerFindByStatusResponseItemsItemDescriptionMin = 10;
export const postsControllerFindByStatusResponseItemsItemDescriptionMax = 500;

export const postsControllerFindByStatusResponseItemsItemIdMin = 24;
export const postsControllerFindByStatusResponseItemsItemIdMax = 24;

export const postsControllerFindByStatusResponseItemsItemAuthorIdMin = 24;
export const postsControllerFindByStatusResponseItemsItemAuthorIdMax = 24;

export const postsControllerFindByStatusResponseItemsItemFilesItemLocationTypeDefault = "Point";export const postsControllerFindByStatusResponseItemsItemFilesItemIdMin = 24;
export const postsControllerFindByStatusResponseItemsItemFilesItemIdMax = 24;

export const postsControllerFindByStatusResponseItemsItemAuthorIdMinOne = 24;
export const postsControllerFindByStatusResponseItemsItemAuthorIdMaxOne = 24;



export const postsControllerFindByStatusResponse = zod.object({
  "items": zod.array(zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsControllerFindByStatusResponseItemsItemProjectIdMin).max(postsControllerFindByStatusResponseItemsItemProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsControllerFindByStatusResponseItemsItemDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerFindByStatusResponseItemsItemTitleMin).max(postsControllerFindByStatusResponseItemsItemTitleMax),
  "slug": zod.string().min(postsControllerFindByStatusResponseItemsItemSlugMin).max(postsControllerFindByStatusResponseItemsItemSlugMax),
  "description": zod.string().min(postsControllerFindByStatusResponseItemsItemDescriptionMin).max(postsControllerFindByStatusResponseItemsItemDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsControllerFindByStatusResponseItemsItemIdMin).max(postsControllerFindByStatusResponseItemsItemIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsControllerFindByStatusResponseItemsItemAuthorIdMin).max(postsControllerFindByStatusResponseItemsItemAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsControllerFindByStatusResponseItemsItemFilesItemIdMin).max(postsControllerFindByStatusResponseItemsItemFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsControllerFindByStatusResponseItemsItemAuthorIdMinOne).max(postsControllerFindByStatusResponseItemsItemAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


/**
 * @summary Get posts by tags with keyset pagination
 */
export const postsControllerFindByTagsQueryParams = zod.object({
  "limit": zod.number().optional().describe('Number of items to return (1-100, default: 20)'),
  "after": zod.string().optional().describe('Cursor token for next page (forward pagination)'),
  "before": zod.string().optional().describe('Cursor token for previous page (backward pagination)'),
  "sort": zod.enum(['title', 'slug', 'createdAt', 'updatedAt', '-title', '-slug', '-createdAt', '-updatedAt']).optional().describe('Sort field with optional \'-\' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt'),
  "domain": zod.string().optional().describe('Filter by domain (exact match)'),
  "domain.contains": zod.string().optional().describe('Filter where domain contains the value (case-sensitive)'),
  "domain.icontains": zod.string().optional().describe('Filter where domain contains the value (case-insensitive)'),
  "domain.startsWith": zod.string().optional().describe('Filter where domain starts with the value (case-sensitive)'),
  "domain.istartswith": zod.string().optional().describe('Filter where domain starts with the value (case-insensitive)'),
  "title": zod.string().optional().describe('Filter by title (exact match)'),
  "title.contains": zod.string().optional().describe('Filter where title contains the value (case-sensitive)'),
  "title.icontains": zod.string().optional().describe('Filter where title contains the value (case-insensitive)'),
  "title.startsWith": zod.string().optional().describe('Filter where title starts with the value (case-sensitive)'),
  "title.istartswith": zod.string().optional().describe('Filter where title starts with the value (case-insensitive)'),
  "slug": zod.string().optional().describe('Filter by slug (exact match)'),
  "slug.contains": zod.string().optional().describe('Filter where slug contains the value (case-sensitive)'),
  "slug.icontains": zod.string().optional().describe('Filter where slug contains the value (case-insensitive)'),
  "slug.startsWith": zod.string().optional().describe('Filter where slug starts with the value (case-sensitive)'),
  "slug.istartswith": zod.string().optional().describe('Filter where slug starts with the value (case-insensitive)'),
  "description": zod.string().optional().describe('Filter by description (exact match)'),
  "description.contains": zod.string().optional().describe('Filter where description contains the value (case-sensitive)'),
  "description.icontains": zod.string().optional().describe('Filter where description contains the value (case-insensitive)'),
  "description.startsWith": zod.string().optional().describe('Filter where description starts with the value (case-sensitive)'),
  "description.istartswith": zod.string().optional().describe('Filter where description starts with the value (case-insensitive)'),
  "tags": zod.string().optional().describe('Filter by tags (exact match)'),
  "tags.contains": zod.string().optional().describe('Filter where tags contains the value (case-sensitive)'),
  "tags.icontains": zod.string().optional().describe('Filter where tags contains the value (case-insensitive)'),
  "tags.startsWith": zod.string().optional().describe('Filter where tags starts with the value (case-sensitive)'),
  "tags.istartswith": zod.string().optional().describe('Filter where tags starts with the value (case-insensitive)'),
  "type": zod.string().optional().describe('Filter by type (exact match)'),
  "type.contains": zod.string().optional().describe('Filter where type contains the value (case-sensitive)'),
  "type.icontains": zod.string().optional().describe('Filter where type contains the value (case-insensitive)'),
  "type.startsWith": zod.string().optional().describe('Filter where type starts with the value (case-sensitive)'),
  "type.istartswith": zod.string().optional().describe('Filter where type starts with the value (case-insensitive)'),
  "status": zod.string().optional().describe('Filter by status (exact match)'),
  "status.contains": zod.string().optional().describe('Filter where status contains the value (case-sensitive)'),
  "status.icontains": zod.string().optional().describe('Filter where status contains the value (case-insensitive)'),
  "status.startsWith": zod.string().optional().describe('Filter where status starts with the value (case-sensitive)'),
  "status.istartswith": zod.string().optional().describe('Filter where status starts with the value (case-insensitive)'),
  "authorId": zod.string().optional().describe('Filter by authorId'),
  "categories": zod.string().optional().describe('Filter by categories'),
  "createdAt": zod.string().optional().describe('Filter by createdAt (exact match, ISO date string for dates)'),
  "createdAt.gt": zod.string().optional().describe('Filter where createdAt is greater than'),
  "createdAt.gte": zod.string().optional().describe('Filter where createdAt is greater than or equal'),
  "createdAt.lt": zod.string().optional().describe('Filter where createdAt is less than'),
  "createdAt.lte": zod.string().optional().describe('Filter where createdAt is less than or equal'),
  "updatedAt": zod.string().optional().describe('Filter by updatedAt (exact match, ISO date string for dates)'),
  "updatedAt.gt": zod.string().optional().describe('Filter where updatedAt is greater than'),
  "updatedAt.gte": zod.string().optional().describe('Filter where updatedAt is greater than or equal'),
  "updatedAt.lt": zod.string().optional().describe('Filter where updatedAt is less than'),
  "updatedAt.lte": zod.string().optional().describe('Filter where updatedAt is less than or equal')
})

export const postsControllerFindByTagsResponseItemsItemProjectIdMin = 24;
export const postsControllerFindByTagsResponseItemsItemProjectIdMax = 24;

export const postsControllerFindByTagsResponseItemsItemDomainMax = 30;

export const postsControllerFindByTagsResponseItemsItemTitleMin = 5;
export const postsControllerFindByTagsResponseItemsItemTitleMax = 120;

export const postsControllerFindByTagsResponseItemsItemSlugMin = 5;
export const postsControllerFindByTagsResponseItemsItemSlugMax = 120;

export const postsControllerFindByTagsResponseItemsItemDescriptionMin = 10;
export const postsControllerFindByTagsResponseItemsItemDescriptionMax = 500;

export const postsControllerFindByTagsResponseItemsItemIdMin = 24;
export const postsControllerFindByTagsResponseItemsItemIdMax = 24;

export const postsControllerFindByTagsResponseItemsItemAuthorIdMin = 24;
export const postsControllerFindByTagsResponseItemsItemAuthorIdMax = 24;

export const postsControllerFindByTagsResponseItemsItemFilesItemLocationTypeDefault = "Point";export const postsControllerFindByTagsResponseItemsItemFilesItemIdMin = 24;
export const postsControllerFindByTagsResponseItemsItemFilesItemIdMax = 24;

export const postsControllerFindByTagsResponseItemsItemAuthorIdMinOne = 24;
export const postsControllerFindByTagsResponseItemsItemAuthorIdMaxOne = 24;



export const postsControllerFindByTagsResponse = zod.object({
  "items": zod.array(zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsControllerFindByTagsResponseItemsItemProjectIdMin).max(postsControllerFindByTagsResponseItemsItemProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsControllerFindByTagsResponseItemsItemDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerFindByTagsResponseItemsItemTitleMin).max(postsControllerFindByTagsResponseItemsItemTitleMax),
  "slug": zod.string().min(postsControllerFindByTagsResponseItemsItemSlugMin).max(postsControllerFindByTagsResponseItemsItemSlugMax),
  "description": zod.string().min(postsControllerFindByTagsResponseItemsItemDescriptionMin).max(postsControllerFindByTagsResponseItemsItemDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsControllerFindByTagsResponseItemsItemIdMin).max(postsControllerFindByTagsResponseItemsItemIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsControllerFindByTagsResponseItemsItemAuthorIdMin).max(postsControllerFindByTagsResponseItemsItemAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsControllerFindByTagsResponseItemsItemFilesItemIdMin).max(postsControllerFindByTagsResponseItemsItemFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsControllerFindByTagsResponseItemsItemAuthorIdMinOne).max(postsControllerFindByTagsResponseItemsItemAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


/**
 * @summary Get posts by author with keyset pagination
 */
export const postsControllerFindByAuthorPathIdMin = 24;
export const postsControllerFindByAuthorPathIdMax = 24;



export const postsControllerFindByAuthorParams = zod.object({
  "id": zod.string().min(postsControllerFindByAuthorPathIdMin).max(postsControllerFindByAuthorPathIdMax).describe('MongoDB ObjectId'),
  "authorId": zod.string()
})

export const postsControllerFindByAuthorQueryParams = zod.object({
  "limit": zod.number().optional().describe('Number of items to return (1-100, default: 20)'),
  "after": zod.string().optional().describe('Cursor token for next page (forward pagination)'),
  "before": zod.string().optional().describe('Cursor token for previous page (backward pagination)'),
  "sort": zod.enum(['title', 'slug', 'createdAt', 'updatedAt', '-title', '-slug', '-createdAt', '-updatedAt']).optional().describe('Sort field with optional \'-\' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt'),
  "domain": zod.string().optional().describe('Filter by domain (exact match)'),
  "domain.contains": zod.string().optional().describe('Filter where domain contains the value (case-sensitive)'),
  "domain.icontains": zod.string().optional().describe('Filter where domain contains the value (case-insensitive)'),
  "domain.startsWith": zod.string().optional().describe('Filter where domain starts with the value (case-sensitive)'),
  "domain.istartswith": zod.string().optional().describe('Filter where domain starts with the value (case-insensitive)'),
  "title": zod.string().optional().describe('Filter by title (exact match)'),
  "title.contains": zod.string().optional().describe('Filter where title contains the value (case-sensitive)'),
  "title.icontains": zod.string().optional().describe('Filter where title contains the value (case-insensitive)'),
  "title.startsWith": zod.string().optional().describe('Filter where title starts with the value (case-sensitive)'),
  "title.istartswith": zod.string().optional().describe('Filter where title starts with the value (case-insensitive)'),
  "slug": zod.string().optional().describe('Filter by slug (exact match)'),
  "slug.contains": zod.string().optional().describe('Filter where slug contains the value (case-sensitive)'),
  "slug.icontains": zod.string().optional().describe('Filter where slug contains the value (case-insensitive)'),
  "slug.startsWith": zod.string().optional().describe('Filter where slug starts with the value (case-sensitive)'),
  "slug.istartswith": zod.string().optional().describe('Filter where slug starts with the value (case-insensitive)'),
  "description": zod.string().optional().describe('Filter by description (exact match)'),
  "description.contains": zod.string().optional().describe('Filter where description contains the value (case-sensitive)'),
  "description.icontains": zod.string().optional().describe('Filter where description contains the value (case-insensitive)'),
  "description.startsWith": zod.string().optional().describe('Filter where description starts with the value (case-sensitive)'),
  "description.istartswith": zod.string().optional().describe('Filter where description starts with the value (case-insensitive)'),
  "tags": zod.string().optional().describe('Filter by tags (exact match)'),
  "tags.contains": zod.string().optional().describe('Filter where tags contains the value (case-sensitive)'),
  "tags.icontains": zod.string().optional().describe('Filter where tags contains the value (case-insensitive)'),
  "tags.startsWith": zod.string().optional().describe('Filter where tags starts with the value (case-sensitive)'),
  "tags.istartswith": zod.string().optional().describe('Filter where tags starts with the value (case-insensitive)'),
  "type": zod.string().optional().describe('Filter by type (exact match)'),
  "type.contains": zod.string().optional().describe('Filter where type contains the value (case-sensitive)'),
  "type.icontains": zod.string().optional().describe('Filter where type contains the value (case-insensitive)'),
  "type.startsWith": zod.string().optional().describe('Filter where type starts with the value (case-sensitive)'),
  "type.istartswith": zod.string().optional().describe('Filter where type starts with the value (case-insensitive)'),
  "status": zod.string().optional().describe('Filter by status (exact match)'),
  "status.contains": zod.string().optional().describe('Filter where status contains the value (case-sensitive)'),
  "status.icontains": zod.string().optional().describe('Filter where status contains the value (case-insensitive)'),
  "status.startsWith": zod.string().optional().describe('Filter where status starts with the value (case-sensitive)'),
  "status.istartswith": zod.string().optional().describe('Filter where status starts with the value (case-insensitive)'),
  "authorId": zod.string().optional().describe('Filter by authorId'),
  "categories": zod.string().optional().describe('Filter by categories'),
  "createdAt": zod.string().optional().describe('Filter by createdAt (exact match, ISO date string for dates)'),
  "createdAt.gt": zod.string().optional().describe('Filter where createdAt is greater than'),
  "createdAt.gte": zod.string().optional().describe('Filter where createdAt is greater than or equal'),
  "createdAt.lt": zod.string().optional().describe('Filter where createdAt is less than'),
  "createdAt.lte": zod.string().optional().describe('Filter where createdAt is less than or equal'),
  "updatedAt": zod.string().optional().describe('Filter by updatedAt (exact match, ISO date string for dates)'),
  "updatedAt.gt": zod.string().optional().describe('Filter where updatedAt is greater than'),
  "updatedAt.gte": zod.string().optional().describe('Filter where updatedAt is greater than or equal'),
  "updatedAt.lt": zod.string().optional().describe('Filter where updatedAt is less than'),
  "updatedAt.lte": zod.string().optional().describe('Filter where updatedAt is less than or equal')
})

export const postsControllerFindByAuthorResponseItemsItemProjectIdMin = 24;
export const postsControllerFindByAuthorResponseItemsItemProjectIdMax = 24;

export const postsControllerFindByAuthorResponseItemsItemDomainMax = 30;

export const postsControllerFindByAuthorResponseItemsItemTitleMin = 5;
export const postsControllerFindByAuthorResponseItemsItemTitleMax = 120;

export const postsControllerFindByAuthorResponseItemsItemSlugMin = 5;
export const postsControllerFindByAuthorResponseItemsItemSlugMax = 120;

export const postsControllerFindByAuthorResponseItemsItemDescriptionMin = 10;
export const postsControllerFindByAuthorResponseItemsItemDescriptionMax = 500;

export const postsControllerFindByAuthorResponseItemsItemIdMin = 24;
export const postsControllerFindByAuthorResponseItemsItemIdMax = 24;

export const postsControllerFindByAuthorResponseItemsItemAuthorIdMin = 24;
export const postsControllerFindByAuthorResponseItemsItemAuthorIdMax = 24;

export const postsControllerFindByAuthorResponseItemsItemFilesItemLocationTypeDefault = "Point";export const postsControllerFindByAuthorResponseItemsItemFilesItemIdMin = 24;
export const postsControllerFindByAuthorResponseItemsItemFilesItemIdMax = 24;

export const postsControllerFindByAuthorResponseItemsItemAuthorIdMinOne = 24;
export const postsControllerFindByAuthorResponseItemsItemAuthorIdMaxOne = 24;



export const postsControllerFindByAuthorResponse = zod.object({
  "items": zod.array(zod.object({
  "createdAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "updatedAt": zod.string().datetime({"local":true,"offset":true,"precision":3}),
  "projectId": zod.string().min(postsControllerFindByAuthorResponseItemsItemProjectIdMin).max(postsControllerFindByAuthorResponseItemsItemProjectIdMax).describe('The unique id'),
  "domain": zod.string().max(postsControllerFindByAuthorResponseItemsItemDomainMax).describe('Domain label for multi-site support (e.g., \"main-website\", \"blog-subsite\")'),
  "title": zod.string().min(postsControllerFindByAuthorResponseItemsItemTitleMin).max(postsControllerFindByAuthorResponseItemsItemTitleMax),
  "slug": zod.string().min(postsControllerFindByAuthorResponseItemsItemSlugMin).max(postsControllerFindByAuthorResponseItemsItemSlugMax),
  "description": zod.string().min(postsControllerFindByAuthorResponseItemsItemDescriptionMin).max(postsControllerFindByAuthorResponseItemsItemDescriptionMax).optional(),
  "content": zod.string().optional(),
  "tags": zod.array(zod.string()).optional(),
  "type": zod.enum(['category', 'post', 'article']).optional(),
  "status": zod.enum(['draft', 'hidden', 'pending', 'scheduled', 'paused', 'active', 'completed', 'published', 'cancelled', 'expired', 'accepted', 'rejected']).optional(),
  "id": zod.string().min(postsControllerFindByAuthorResponseItemsItemIdMin).max(postsControllerFindByAuthorResponseItemsItemIdMax).describe('The unique id'),
  "authorId": zod.string().min(postsControllerFindByAuthorResponseItemsItemAuthorIdMin).max(postsControllerFindByAuthorResponseItemsItemAuthorIdMax).describe('The unique id of the author'),
  "files": zod.array(zod.object({
  "altText": zod.string(),
  "exif": zod.object({
  "Model": zod.string(),
  "Lens": zod.string(),
  "ISOSpeedRatings": zod.string(),
  "FocalLength": zod.string(),
  "FNumber": zod.string(),
  "ExposureTime": zod.string(),
  "WhiteBalance": zod.string(),
  "MeteringMode": zod.string(),
  "DateTime": zod.string(),
  "GPSLatitude": zod.string(),
  "GPSLongitude": zod.string()
}).optional(),
  "location": zod.object({
  "type": zod.string(),
  "coordinates": zod.array(zod.number())
}).optional(),
  "src": zod.string(),
  "type": zod.string(),
  "id": zod.string().min(postsControllerFindByAuthorResponseItemsItemFilesItemIdMin).max(postsControllerFindByAuthorResponseItemsItemFilesItemIdMax).describe('The unique id')
})).optional().describe('Post files (origin field excluded)'),
  "author": zod.object({
  "id": zod.string().min(postsControllerFindByAuthorResponseItemsItemAuthorIdMinOne).max(postsControllerFindByAuthorResponseItemsItemAuthorIdMaxOne).describe('The unique id of the author'),
  "name": zod.string().describe('Author name'),
  "username": zod.string().optional().describe('Author username (falls back to userId if username not found)')
}).optional().describe('Post author information (populated)'),
  "categories": zod.array(zod.object({
  "id": zod.string().describe('The unique id'),
  "slug": zod.string().describe('Category slug'),
  "title": zod.string().describe('Category title')
})).optional().describe('Post categories (populated)')
})).optional(),
  "meta": zod.object({
  "nextCursor": zod.string().optional(),
  "prevCursor": zod.string().optional(),
  "hasNextPage": zod.boolean(),
  "hasPrevPage": zod.boolean(),
  "limit": zod.number(),
  "sort": zod.string(),
  "order": zod.enum(['asc', 'desc'])
}).optional()
})


export const fileControllerUploadBody = zod.object({
  "file": zod.instanceof(File).optional().describe('The file to upload')
})
