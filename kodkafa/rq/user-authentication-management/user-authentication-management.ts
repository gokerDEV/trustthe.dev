/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * KODKAFA API
 * Stack: Nest.js + MongoDB + Mongoose + Redis - OAuth 2.1 Compliant
 * OpenAPI spec version: 0.0.3
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthControllerLogin200,
  AuthControllerRefresh200,
  AuthControllerRegister201,
  AuthControllerResetPassword200,
  AuthControllerResetPasswordBody,
  LoginDto,
  OkDto,
  RecoveryDto,
  RegisterDto,
  UpdatePasswordDto,
  UserSessionDto
} from '../kodkafaApi.schemas';

import { clientMutator } from '../../../lib/api/client.mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Register a new user
 */
export type authControllerRegisterResponse201 = {
  data: AuthControllerRegister201
  status: 201
}
    
export type authControllerRegisterResponseSuccess = (authControllerRegisterResponse201) & {
  headers: Headers;
};
;

export type authControllerRegisterResponse = (authControllerRegisterResponseSuccess)

export const getAuthControllerRegisterUrl = () => {


  

  return `/api/auth/register`
}

export const authControllerRegister = async (registerDto: RegisterDto, options?: RequestInit): Promise<authControllerRegisterResponse> => {
  
  return clientMutator<authControllerRegisterResponse>(getAuthControllerRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerDto,)
  }
);}




export const getAuthControllerRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext> => {

const mutationKey = ['authControllerRegister'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRegister>>, {data: RegisterDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRegister(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>
    export type AuthControllerRegisterMutationBody = RegisterDto
    export type AuthControllerRegisterMutationError = unknown

    /**
 * @summary Register a new user
 */
export const useAuthControllerRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRegister>>,
        TError,
        {data: RegisterDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Log in a user
 */
export type authControllerLoginResponse200 = {
  data: AuthControllerLogin200
  status: 200
}
    
export type authControllerLoginResponseSuccess = (authControllerLoginResponse200) & {
  headers: Headers;
};
;

export type authControllerLoginResponse = (authControllerLoginResponseSuccess)

export const getAuthControllerLoginUrl = () => {


  

  return `/api/auth/login`
}

export const authControllerLogin = async (loginDto: LoginDto, options?: RequestInit): Promise<authControllerLoginResponse> => {
  
  return clientMutator<authControllerLoginResponse>(getAuthControllerLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginDto,)
  }
);}




export const getAuthControllerLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    export type AuthControllerLoginMutationBody = LoginDto
    export type AuthControllerLoginMutationError = unknown

    /**
 * @summary Log in a user
 */
export const useAuthControllerLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Refresh an access token
 */
export type authControllerRefreshResponse200 = {
  data: AuthControllerRefresh200
  status: 200
}
    
export type authControllerRefreshResponseSuccess = (authControllerRefreshResponse200) & {
  headers: Headers;
};
;

export type authControllerRefreshResponse = (authControllerRefreshResponseSuccess)

export const getAuthControllerRefreshUrl = () => {


  

  return `/api/auth/refresh`
}

export const authControllerRefresh = async ( options?: RequestInit): Promise<authControllerRefreshResponse> => {
  
  return clientMutator<authControllerRefreshResponse>(getAuthControllerRefreshUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAuthControllerRefreshMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefresh>>, TError,void, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRefresh>>, TError,void, TContext> => {

const mutationKey = ['authControllerRefresh'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRefresh>>, void> = () => {
          

          return  authControllerRefresh(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRefresh>>>
    
    export type AuthControllerRefreshMutationError = unknown

    /**
 * @summary Refresh an access token
 */
export const useAuthControllerRefresh = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRefresh>>, TError,void, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRefresh>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerRefreshMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Log out the current session
 */
export type authControllerLogoutResponse200 = {
  data: OkDto
  status: 200
}
    
export type authControllerLogoutResponseSuccess = (authControllerLogoutResponse200) & {
  headers: Headers;
};
;

export type authControllerLogoutResponse = (authControllerLogoutResponseSuccess)

export const getAuthControllerLogoutUrl = () => {


  

  return `/api/auth/logout`
}

export const authControllerLogout = async ( options?: RequestInit): Promise<authControllerLogoutResponse> => {
  
  return clientMutator<authControllerLogoutResponse>(getAuthControllerLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getAuthControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
          

          return  authControllerLogout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
    
    export type AuthControllerLogoutMutationError = unknown

    /**
 * @summary Log out the current session
 */
export const useAuthControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Initiate password recovery
 */
export type authControllerRecoveryResponse200 = {
  data: OkDto
  status: 200
}
    
export type authControllerRecoveryResponseSuccess = (authControllerRecoveryResponse200) & {
  headers: Headers;
};
;

export type authControllerRecoveryResponse = (authControllerRecoveryResponseSuccess)

export const getAuthControllerRecoveryUrl = () => {


  

  return `/api/auth/recovery`
}

export const authControllerRecovery = async (recoveryDto: RecoveryDto, options?: RequestInit): Promise<authControllerRecoveryResponse> => {
  
  return clientMutator<authControllerRecoveryResponse>(getAuthControllerRecoveryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      recoveryDto,)
  }
);}




export const getAuthControllerRecoveryMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRecovery>>, TError,{data: RecoveryDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRecovery>>, TError,{data: RecoveryDto}, TContext> => {

const mutationKey = ['authControllerRecovery'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRecovery>>, {data: RecoveryDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRecovery(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRecoveryMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRecovery>>>
    export type AuthControllerRecoveryMutationBody = RecoveryDto
    export type AuthControllerRecoveryMutationError = unknown

    /**
 * @summary Initiate password recovery
 */
export const useAuthControllerRecovery = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRecovery>>, TError,{data: RecoveryDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRecovery>>,
        TError,
        {data: RecoveryDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerRecoveryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Reset password using a recovery token
 */
export type authControllerResetPasswordResponse200 = {
  data: AuthControllerResetPassword200
  status: 200
}
    
export type authControllerResetPasswordResponseSuccess = (authControllerResetPasswordResponse200) & {
  headers: Headers;
};
;

export type authControllerResetPasswordResponse = (authControllerResetPasswordResponseSuccess)

export const getAuthControllerResetPasswordUrl = () => {


  

  return `/api/auth/reset-password`
}

export const authControllerResetPassword = async (authControllerResetPasswordBody: AuthControllerResetPasswordBody, options?: RequestInit): Promise<authControllerResetPasswordResponse> => {
  
  return clientMutator<authControllerResetPasswordResponse>(getAuthControllerResetPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      authControllerResetPasswordBody,)
  }
);}




export const getAuthControllerResetPasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPassword>>, TError,{data: AuthControllerResetPasswordBody}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPassword>>, TError,{data: AuthControllerResetPasswordBody}, TContext> => {

const mutationKey = ['authControllerResetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerResetPassword>>, {data: AuthControllerResetPasswordBody}> = (props) => {
          const {data} = props ?? {};

          return  authControllerResetPassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerResetPassword>>>
    export type AuthControllerResetPasswordMutationBody = AuthControllerResetPasswordBody
    export type AuthControllerResetPasswordMutationError = unknown

    /**
 * @summary Reset password using a recovery token
 */
export const useAuthControllerResetPassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerResetPassword>>, TError,{data: AuthControllerResetPasswordBody}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerResetPassword>>,
        TError,
        {data: AuthControllerResetPasswordBody},
        TContext
      > => {

      const mutationOptions = getAuthControllerResetPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Change password for an authenticated user
 */
export type authControllerChangePasswordResponse200 = {
  data: OkDto
  status: 200
}
    
export type authControllerChangePasswordResponseSuccess = (authControllerChangePasswordResponse200) & {
  headers: Headers;
};
;

export type authControllerChangePasswordResponse = (authControllerChangePasswordResponseSuccess)

export const getAuthControllerChangePasswordUrl = () => {


  

  return `/api/auth/change-password`
}

export const authControllerChangePassword = async (updatePasswordDto: UpdatePasswordDto, options?: RequestInit): Promise<authControllerChangePasswordResponse> => {
  
  return clientMutator<authControllerChangePasswordResponse>(getAuthControllerChangePasswordUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePasswordDto,)
  }
);}




export const getAuthControllerChangePasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerChangePassword>>, TError,{data: UpdatePasswordDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerChangePassword>>, TError,{data: UpdatePasswordDto}, TContext> => {

const mutationKey = ['authControllerChangePassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerChangePassword>>, {data: UpdatePasswordDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerChangePassword(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerChangePassword>>>
    export type AuthControllerChangePasswordMutationBody = UpdatePasswordDto
    export type AuthControllerChangePasswordMutationError = unknown

    /**
 * @summary Change password for an authenticated user
 */
export const useAuthControllerChangePassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerChangePassword>>, TError,{data: UpdatePasswordDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerChangePassword>>,
        TError,
        {data: UpdatePasswordDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerChangePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get the current user's active sessions
 */
export type authControllerGetSessionsResponse200 = {
  data: UserSessionDto[]
  status: 200
}
    
export type authControllerGetSessionsResponseSuccess = (authControllerGetSessionsResponse200) & {
  headers: Headers;
};
;

export type authControllerGetSessionsResponse = (authControllerGetSessionsResponseSuccess)

export const getAuthControllerGetSessionsUrl = () => {


  

  return `/api/auth/sessions`
}

export const authControllerGetSessions = async ( options?: RequestInit): Promise<authControllerGetSessionsResponse> => {
  
  return clientMutator<authControllerGetSessionsResponse>(getAuthControllerGetSessionsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAuthControllerGetSessionsInfiniteQueryKey = () => {
    return [
    'infinite', `/api/auth/sessions`
    ] as const;
    }

export const getAuthControllerGetSessionsQueryKey = () => {
    return [
    `/api/auth/sessions`
    ] as const;
    }

    
export const getAuthControllerGetSessionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetSessions>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetSessionsInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetSessions>>> = ({ signal }) => authControllerGetSessions({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetSessionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetSessions>>>
export type AuthControllerGetSessionsInfiniteQueryError = unknown


export function useAuthControllerGetSessionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetSessions>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetSessions>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetSessions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetSessionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetSessions>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetSessions>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetSessions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetSessionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetSessions>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current user's active sessions
 */

export function useAuthControllerGetSessionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerGetSessions>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerGetSessionsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAuthControllerGetSessionsQueryOptions = <TData = Awaited<ReturnType<typeof authControllerGetSessions>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerGetSessionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerGetSessions>>> = ({ signal }) => authControllerGetSessions({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerGetSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetSessions>>>
export type AuthControllerGetSessionsQueryError = unknown


export function useAuthControllerGetSessions<TData = Awaited<ReturnType<typeof authControllerGetSessions>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetSessions>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetSessions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetSessions<TData = Awaited<ReturnType<typeof authControllerGetSessions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerGetSessions>>,
          TError,
          Awaited<ReturnType<typeof authControllerGetSessions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerGetSessions<TData = Awaited<ReturnType<typeof authControllerGetSessions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current user's active sessions
 */

export function useAuthControllerGetSessions<TData = Awaited<ReturnType<typeof authControllerGetSessions>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerGetSessions>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerGetSessionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Log out all sessions for the current user
 */
export type authControllerDropAllSessionsResponse200 = {
  data: OkDto
  status: 200
}
    
export type authControllerDropAllSessionsResponseSuccess = (authControllerDropAllSessionsResponse200) & {
  headers: Headers;
};
;

export type authControllerDropAllSessionsResponse = (authControllerDropAllSessionsResponseSuccess)

export const getAuthControllerDropAllSessionsUrl = () => {


  

  return `/api/auth/sessions`
}

export const authControllerDropAllSessions = async ( options?: RequestInit): Promise<authControllerDropAllSessionsResponse> => {
  
  return clientMutator<authControllerDropAllSessionsResponse>(getAuthControllerDropAllSessionsUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getAuthControllerDropAllSessionsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerDropAllSessions>>, TError,void, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerDropAllSessions>>, TError,void, TContext> => {

const mutationKey = ['authControllerDropAllSessions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerDropAllSessions>>, void> = () => {
          

          return  authControllerDropAllSessions(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerDropAllSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerDropAllSessions>>>
    
    export type AuthControllerDropAllSessionsMutationError = unknown

    /**
 * @summary Log out all sessions for the current user
 */
export const useAuthControllerDropAllSessions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerDropAllSessions>>, TError,void, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerDropAllSessions>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerDropAllSessionsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Log out a specific session by its key
 */
export type authControllerDropSessionResponse200 = {
  data: OkDto
  status: 200
}
    
export type authControllerDropSessionResponseSuccess = (authControllerDropSessionResponse200) & {
  headers: Headers;
};
;

export type authControllerDropSessionResponse = (authControllerDropSessionResponseSuccess)

export const getAuthControllerDropSessionUrl = (key: string,) => {


  

  return `/api/auth/sessions/${key}`
}

export const authControllerDropSession = async (key: string, options?: RequestInit): Promise<authControllerDropSessionResponse> => {
  
  return clientMutator<authControllerDropSessionResponse>(getAuthControllerDropSessionUrl(key),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getAuthControllerDropSessionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerDropSession>>, TError,{key: string}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerDropSession>>, TError,{key: string}, TContext> => {

const mutationKey = ['authControllerDropSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerDropSession>>, {key: string}> = (props) => {
          const {key} = props ?? {};

          return  authControllerDropSession(key,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerDropSessionMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerDropSession>>>
    
    export type AuthControllerDropSessionMutationError = unknown

    /**
 * @summary Log out a specific session by its key
 */
export const useAuthControllerDropSession = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerDropSession>>, TError,{key: string}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerDropSession>>,
        TError,
        {key: string},
        TContext
      > => {

      const mutationOptions = getAuthControllerDropSessionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    