/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * KODKAFA API
 * Stack: Nest.js + MongoDB + Mongoose + Redis - OAuth 2.1 Compliant
 * OpenAPI spec version: 0.0.3
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreatePostDto,
  ErrorResponseDto,
  PostDto,
  PostsControllerFindByAuthor200,
  PostsControllerFindByAuthorParams,
  PostsControllerFindByDomain200,
  PostsControllerFindByDomainParams,
  PostsControllerFindByStatus200,
  PostsControllerFindByStatusParams,
  PostsControllerFindByTags200,
  PostsControllerFindByTagsParams,
  ResponseIdDto,
  UpdatePostDto
} from '../kodkafaApi.schemas';

import { clientMutator } from '../../../lib/api/client.mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create a new post
 */
export type postsControllerCreateResponse201 = {
  data: ResponseIdDto
  status: 201
}

export type postsControllerCreateResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerCreateResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerCreateResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerCreateResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerCreateResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerCreateResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerCreateResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerCreateResponseSuccess = (postsControllerCreateResponse201) & {
  headers: Headers;
};
export type postsControllerCreateResponseError = (postsControllerCreateResponse400 | postsControllerCreateResponse401 | postsControllerCreateResponse403 | postsControllerCreateResponse404 | postsControllerCreateResponse409 | postsControllerCreateResponse422 | postsControllerCreateResponse500) & {
  headers: Headers;
};

export type postsControllerCreateResponse = (postsControllerCreateResponseSuccess | postsControllerCreateResponseError)

export const getPostsControllerCreateUrl = () => {


  

  return `/api/posts`
}

export const postsControllerCreate = async (createPostDto: CreatePostDto, options?: RequestInit): Promise<postsControllerCreateResponse> => {
  
  return clientMutator<postsControllerCreateResponse>(getPostsControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostDto,)
  }
);}




export const getPostsControllerCreateMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsControllerCreate>>, TError,{data: CreatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postsControllerCreate>>, TError,{data: CreatePostDto}, TContext> => {

const mutationKey = ['postsControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsControllerCreate>>, {data: CreatePostDto}> = (props) => {
          const {data} = props ?? {};

          return  postsControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof postsControllerCreate>>>
    export type PostsControllerCreateMutationBody = CreatePostDto
    export type PostsControllerCreateMutationError = ErrorResponseDto

    /**
 * @summary Create a new post
 */
export const usePostsControllerCreate = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsControllerCreate>>, TError,{data: CreatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsControllerCreate>>,
        TError,
        {data: CreatePostDto},
        TContext
      > => {

      const mutationOptions = getPostsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get post by ID
 */
export type postsControllerFindOneResponse200 = {
  data: PostDto
  status: 200
}

export type postsControllerFindOneResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerFindOneResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerFindOneResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerFindOneResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerFindOneResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerFindOneResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerFindOneResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerFindOneResponseSuccess = (postsControllerFindOneResponse200) & {
  headers: Headers;
};
export type postsControllerFindOneResponseError = (postsControllerFindOneResponse400 | postsControllerFindOneResponse401 | postsControllerFindOneResponse403 | postsControllerFindOneResponse404 | postsControllerFindOneResponse409 | postsControllerFindOneResponse422 | postsControllerFindOneResponse500) & {
  headers: Headers;
};

export type postsControllerFindOneResponse = (postsControllerFindOneResponseSuccess | postsControllerFindOneResponseError)

export const getPostsControllerFindOneUrl = (id: string,) => {


  

  return `/api/posts/${id}`
}

export const postsControllerFindOne = async (id: string, options?: RequestInit): Promise<postsControllerFindOneResponse> => {
  
  return clientMutator<postsControllerFindOneResponse>(getPostsControllerFindOneUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPostsControllerFindOneInfiniteQueryKey = (id?: string,) => {
    return [
    'infinite', `/api/posts/${id}`
    ] as const;
    }

export const getPostsControllerFindOneQueryKey = (id?: string,) => {
    return [
    `/api/posts/${id}`
    ] as const;
    }

    
export const getPostsControllerFindOneInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOne>>>, TError = ErrorResponseDto>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindOneInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindOne>>> = ({ signal }) => postsControllerFindOne(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindOneInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindOne>>>
export type PostsControllerFindOneInfiniteQueryError = ErrorResponseDto


export function usePostsControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOne>>>, TError = ErrorResponseDto>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOne>>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOne>>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get post by ID
 */

export function usePostsControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOne>>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindOneInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPostsControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof postsControllerFindOne>>, TError = ErrorResponseDto>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindOne>>> = ({ signal }) => postsControllerFindOne(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindOne>>>
export type PostsControllerFindOneQueryError = ErrorResponseDto


export function usePostsControllerFindOne<TData = Awaited<ReturnType<typeof postsControllerFindOne>>, TError = ErrorResponseDto>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOne<TData = Awaited<ReturnType<typeof postsControllerFindOne>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOne<TData = Awaited<ReturnType<typeof postsControllerFindOne>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get post by ID
 */

export function usePostsControllerFindOne<TData = Awaited<ReturnType<typeof postsControllerFindOne>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update post by ID
 */
export type postsControllerUpdateResponse200 = {
  data: ResponseIdDto
  status: 200
}

export type postsControllerUpdateResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerUpdateResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerUpdateResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerUpdateResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerUpdateResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerUpdateResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerUpdateResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerUpdateResponseSuccess = (postsControllerUpdateResponse200) & {
  headers: Headers;
};
export type postsControllerUpdateResponseError = (postsControllerUpdateResponse400 | postsControllerUpdateResponse401 | postsControllerUpdateResponse403 | postsControllerUpdateResponse404 | postsControllerUpdateResponse409 | postsControllerUpdateResponse422 | postsControllerUpdateResponse500) & {
  headers: Headers;
};

export type postsControllerUpdateResponse = (postsControllerUpdateResponseSuccess | postsControllerUpdateResponseError)

export const getPostsControllerUpdateUrl = (id: string,) => {


  

  return `/api/posts/${id}`
}

export const postsControllerUpdate = async (id: string,
    updatePostDto: UpdatePostDto, options?: RequestInit): Promise<postsControllerUpdateResponse> => {
  
  return clientMutator<postsControllerUpdateResponse>(getPostsControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePostDto,)
  }
);}




export const getPostsControllerUpdateMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsControllerUpdate>>, TError,{id: string;data: UpdatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postsControllerUpdate>>, TError,{id: string;data: UpdatePostDto}, TContext> => {

const mutationKey = ['postsControllerUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsControllerUpdate>>, {id: string;data: UpdatePostDto}> = (props) => {
          const {id,data} = props ?? {};

          return  postsControllerUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof postsControllerUpdate>>>
    export type PostsControllerUpdateMutationBody = UpdatePostDto
    export type PostsControllerUpdateMutationError = ErrorResponseDto

    /**
 * @summary Update post by ID
 */
export const usePostsControllerUpdate = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsControllerUpdate>>, TError,{id: string;data: UpdatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsControllerUpdate>>,
        TError,
        {id: string;data: UpdatePostDto},
        TContext
      > => {

      const mutationOptions = getPostsControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete post by ID
 */
export type postsControllerDeleteResponse200 = {
  data: ResponseIdDto
  status: 200
}

export type postsControllerDeleteResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerDeleteResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerDeleteResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerDeleteResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerDeleteResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerDeleteResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerDeleteResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerDeleteResponseSuccess = (postsControllerDeleteResponse200) & {
  headers: Headers;
};
export type postsControllerDeleteResponseError = (postsControllerDeleteResponse400 | postsControllerDeleteResponse401 | postsControllerDeleteResponse403 | postsControllerDeleteResponse404 | postsControllerDeleteResponse409 | postsControllerDeleteResponse422 | postsControllerDeleteResponse500) & {
  headers: Headers;
};

export type postsControllerDeleteResponse = (postsControllerDeleteResponseSuccess | postsControllerDeleteResponseError)

export const getPostsControllerDeleteUrl = (id: string,) => {


  

  return `/api/posts/${id}`
}

export const postsControllerDelete = async (id: string, options?: RequestInit): Promise<postsControllerDeleteResponse> => {
  
  return clientMutator<postsControllerDeleteResponse>(getPostsControllerDeleteUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getPostsControllerDeleteMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof postsControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['postsControllerDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postsControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  postsControllerDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostsControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof postsControllerDelete>>>
    
    export type PostsControllerDeleteMutationError = ErrorResponseDto

    /**
 * @summary Delete post by ID
 */
export const usePostsControllerDelete = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postsControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postsControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPostsControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get post by slug and domain
 */
export type postsControllerFindOneBySlugResponse200 = {
  data: PostDto
  status: 200
}

export type postsControllerFindOneBySlugResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerFindOneBySlugResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerFindOneBySlugResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerFindOneBySlugResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerFindOneBySlugResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerFindOneBySlugResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerFindOneBySlugResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerFindOneBySlugResponseSuccess = (postsControllerFindOneBySlugResponse200) & {
  headers: Headers;
};
export type postsControllerFindOneBySlugResponseError = (postsControllerFindOneBySlugResponse400 | postsControllerFindOneBySlugResponse401 | postsControllerFindOneBySlugResponse403 | postsControllerFindOneBySlugResponse404 | postsControllerFindOneBySlugResponse409 | postsControllerFindOneBySlugResponse422 | postsControllerFindOneBySlugResponse500) & {
  headers: Headers;
};

export type postsControllerFindOneBySlugResponse = (postsControllerFindOneBySlugResponseSuccess | postsControllerFindOneBySlugResponseError)

export const getPostsControllerFindOneBySlugUrl = (domain: string,
    slug: string,) => {


  

  return `/api/posts/${domain}/by-slug/${slug}`
}

export const postsControllerFindOneBySlug = async (domain: string,
    slug: string, options?: RequestInit): Promise<postsControllerFindOneBySlugResponse> => {
  
  return clientMutator<postsControllerFindOneBySlugResponse>(getPostsControllerFindOneBySlugUrl(domain,slug),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPostsControllerFindOneBySlugInfiniteQueryKey = (domain?: string,
    slug?: string,) => {
    return [
    'infinite', `/api/posts/${domain}/by-slug/${slug}`
    ] as const;
    }

export const getPostsControllerFindOneBySlugQueryKey = (domain?: string,
    slug?: string,) => {
    return [
    `/api/posts/${domain}/by-slug/${slug}`
    ] as const;
    }

    
export const getPostsControllerFindOneBySlugInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>, TError = ErrorResponseDto>(domain: string,
    slug: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindOneBySlugInfiniteQueryKey(domain,slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>> = ({ signal }) => postsControllerFindOneBySlug(domain,slug, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain && slug),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindOneBySlugInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>
export type PostsControllerFindOneBySlugInfiniteQueryError = ErrorResponseDto


export function usePostsControllerFindOneBySlugInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOneBySlugInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOneBySlugInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get post by slug and domain
 */

export function usePostsControllerFindOneBySlugInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindOneBySlugInfiniteQueryOptions(domain,slug,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPostsControllerFindOneBySlugQueryOptions = <TData = Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError = ErrorResponseDto>(domain: string,
    slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindOneBySlugQueryKey(domain,slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>> = ({ signal }) => postsControllerFindOneBySlug(domain,slug, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain && slug),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindOneBySlugQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>>
export type PostsControllerFindOneBySlugQueryError = ErrorResponseDto


export function usePostsControllerFindOneBySlug<TData = Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOneBySlug<TData = Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindOneBySlug>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindOneBySlug<TData = Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get post by slug and domain
 */

export function usePostsControllerFindOneBySlug<TData = Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError = ErrorResponseDto>(
 domain: string,
    slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindOneBySlug>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindOneBySlugQueryOptions(domain,slug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get posts by domain with keyset pagination
 */
export type postsControllerFindByDomainResponse200 = {
  data: PostsControllerFindByDomain200
  status: 200
}

export type postsControllerFindByDomainResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerFindByDomainResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerFindByDomainResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerFindByDomainResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerFindByDomainResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerFindByDomainResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerFindByDomainResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerFindByDomainResponseSuccess = (postsControllerFindByDomainResponse200) & {
  headers: Headers;
};
export type postsControllerFindByDomainResponseError = (postsControllerFindByDomainResponse400 | postsControllerFindByDomainResponse401 | postsControllerFindByDomainResponse403 | postsControllerFindByDomainResponse404 | postsControllerFindByDomainResponse409 | postsControllerFindByDomainResponse422 | postsControllerFindByDomainResponse500) & {
  headers: Headers;
};

export type postsControllerFindByDomainResponse = (postsControllerFindByDomainResponseSuccess | postsControllerFindByDomainResponseError)

export const getPostsControllerFindByDomainUrl = (domain: string,
    params?: PostsControllerFindByDomainParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/posts/domain/${domain}?${stringifiedParams}` : `/api/posts/domain/${domain}`
}

export const postsControllerFindByDomain = async (domain: string,
    params?: PostsControllerFindByDomainParams, options?: RequestInit): Promise<postsControllerFindByDomainResponse> => {
  
  return clientMutator<postsControllerFindByDomainResponse>(getPostsControllerFindByDomainUrl(domain,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPostsControllerFindByDomainInfiniteQueryKey = (domain?: string,
    params?: PostsControllerFindByDomainParams,) => {
    return [
    'infinite', `/api/posts/domain/${domain}`, ...(params ? [params]: [])
    ] as const;
    }

export const getPostsControllerFindByDomainQueryKey = (domain?: string,
    params?: PostsControllerFindByDomainParams,) => {
    return [
    `/api/posts/domain/${domain}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPostsControllerFindByDomainInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByDomain>>>, TError = ErrorResponseDto>(domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByDomainInfiniteQueryKey(domain,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByDomain>>> = ({ signal }) => postsControllerFindByDomain(domain,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByDomainInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByDomain>>>
export type PostsControllerFindByDomainInfiniteQueryError = ErrorResponseDto


export function usePostsControllerFindByDomainInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByDomain>>>, TError = ErrorResponseDto>(
 domain: string,
    params: undefined |  PostsControllerFindByDomainParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByDomain>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByDomain>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByDomainInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByDomain>>>, TError = ErrorResponseDto>(
 domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByDomain>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByDomain>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByDomainInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByDomain>>>, TError = ErrorResponseDto>(
 domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by domain with keyset pagination
 */

export function usePostsControllerFindByDomainInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByDomain>>>, TError = ErrorResponseDto>(
 domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByDomainInfiniteQueryOptions(domain,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPostsControllerFindByDomainQueryOptions = <TData = Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError = ErrorResponseDto>(domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByDomainQueryKey(domain,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByDomain>>> = ({ signal }) => postsControllerFindByDomain(domain,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domain),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByDomainQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByDomain>>>
export type PostsControllerFindByDomainQueryError = ErrorResponseDto


export function usePostsControllerFindByDomain<TData = Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError = ErrorResponseDto>(
 domain: string,
    params: undefined |  PostsControllerFindByDomainParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByDomain>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByDomain>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByDomain<TData = Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError = ErrorResponseDto>(
 domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByDomain>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByDomain>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByDomain<TData = Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError = ErrorResponseDto>(
 domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by domain with keyset pagination
 */

export function usePostsControllerFindByDomain<TData = Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError = ErrorResponseDto>(
 domain: string,
    params?: PostsControllerFindByDomainParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByDomain>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByDomainQueryOptions(domain,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get posts by status with keyset pagination
 */
export type postsControllerFindByStatusResponse200 = {
  data: PostsControllerFindByStatus200
  status: 200
}

export type postsControllerFindByStatusResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerFindByStatusResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerFindByStatusResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerFindByStatusResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerFindByStatusResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerFindByStatusResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerFindByStatusResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerFindByStatusResponseSuccess = (postsControllerFindByStatusResponse200) & {
  headers: Headers;
};
export type postsControllerFindByStatusResponseError = (postsControllerFindByStatusResponse400 | postsControllerFindByStatusResponse401 | postsControllerFindByStatusResponse403 | postsControllerFindByStatusResponse404 | postsControllerFindByStatusResponse409 | postsControllerFindByStatusResponse422 | postsControllerFindByStatusResponse500) & {
  headers: Headers;
};

export type postsControllerFindByStatusResponse = (postsControllerFindByStatusResponseSuccess | postsControllerFindByStatusResponseError)

export const getPostsControllerFindByStatusUrl = (status: string,
    params?: PostsControllerFindByStatusParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/posts/status/${status}?${stringifiedParams}` : `/api/posts/status/${status}`
}

export const postsControllerFindByStatus = async (status: string,
    params?: PostsControllerFindByStatusParams, options?: RequestInit): Promise<postsControllerFindByStatusResponse> => {
  
  return clientMutator<postsControllerFindByStatusResponse>(getPostsControllerFindByStatusUrl(status,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPostsControllerFindByStatusInfiniteQueryKey = (status?: string,
    params?: PostsControllerFindByStatusParams,) => {
    return [
    'infinite', `/api/posts/status/${status}`, ...(params ? [params]: [])
    ] as const;
    }

export const getPostsControllerFindByStatusQueryKey = (status?: string,
    params?: PostsControllerFindByStatusParams,) => {
    return [
    `/api/posts/status/${status}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPostsControllerFindByStatusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByStatus>>>, TError = ErrorResponseDto>(status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByStatusInfiniteQueryKey(status,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByStatus>>> = ({ signal }) => postsControllerFindByStatus(status,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(status),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByStatusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByStatus>>>
export type PostsControllerFindByStatusInfiniteQueryError = ErrorResponseDto


export function usePostsControllerFindByStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByStatus>>>, TError = ErrorResponseDto>(
 status: string,
    params: undefined |  PostsControllerFindByStatusParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByStatus>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByStatus>>>, TError = ErrorResponseDto>(
 status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByStatus>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByStatus>>>, TError = ErrorResponseDto>(
 status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by status with keyset pagination
 */

export function usePostsControllerFindByStatusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByStatus>>>, TError = ErrorResponseDto>(
 status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByStatusInfiniteQueryOptions(status,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPostsControllerFindByStatusQueryOptions = <TData = Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError = ErrorResponseDto>(status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByStatusQueryKey(status,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByStatus>>> = ({ signal }) => postsControllerFindByStatus(status,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(status),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByStatusQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByStatus>>>
export type PostsControllerFindByStatusQueryError = ErrorResponseDto


export function usePostsControllerFindByStatus<TData = Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError = ErrorResponseDto>(
 status: string,
    params: undefined |  PostsControllerFindByStatusParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByStatus>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByStatus<TData = Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError = ErrorResponseDto>(
 status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByStatus>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByStatus<TData = Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError = ErrorResponseDto>(
 status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by status with keyset pagination
 */

export function usePostsControllerFindByStatus<TData = Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError = ErrorResponseDto>(
 status: string,
    params?: PostsControllerFindByStatusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByStatus>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByStatusQueryOptions(status,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get posts by tags with keyset pagination
 */
export type postsControllerFindByTagsResponse200 = {
  data: PostsControllerFindByTags200
  status: 200
}

export type postsControllerFindByTagsResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerFindByTagsResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerFindByTagsResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerFindByTagsResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerFindByTagsResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerFindByTagsResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerFindByTagsResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerFindByTagsResponseSuccess = (postsControllerFindByTagsResponse200) & {
  headers: Headers;
};
export type postsControllerFindByTagsResponseError = (postsControllerFindByTagsResponse400 | postsControllerFindByTagsResponse401 | postsControllerFindByTagsResponse403 | postsControllerFindByTagsResponse404 | postsControllerFindByTagsResponse409 | postsControllerFindByTagsResponse422 | postsControllerFindByTagsResponse500) & {
  headers: Headers;
};

export type postsControllerFindByTagsResponse = (postsControllerFindByTagsResponseSuccess | postsControllerFindByTagsResponseError)

export const getPostsControllerFindByTagsUrl = (params?: PostsControllerFindByTagsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/posts/by-tags?${stringifiedParams}` : `/api/posts/by-tags`
}

export const postsControllerFindByTags = async (params?: PostsControllerFindByTagsParams, options?: RequestInit): Promise<postsControllerFindByTagsResponse> => {
  
  return clientMutator<postsControllerFindByTagsResponse>(getPostsControllerFindByTagsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPostsControllerFindByTagsInfiniteQueryKey = (params?: PostsControllerFindByTagsParams,) => {
    return [
    'infinite', `/api/posts/by-tags`, ...(params ? [params]: [])
    ] as const;
    }

export const getPostsControllerFindByTagsQueryKey = (params?: PostsControllerFindByTagsParams,) => {
    return [
    `/api/posts/by-tags`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPostsControllerFindByTagsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByTags>>>, TError = ErrorResponseDto>(params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByTagsInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByTags>>> = ({ signal }) => postsControllerFindByTags(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByTagsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByTags>>>
export type PostsControllerFindByTagsInfiniteQueryError = ErrorResponseDto


export function usePostsControllerFindByTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByTags>>>, TError = ErrorResponseDto>(
 params: undefined |  PostsControllerFindByTagsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByTags>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByTags>>>, TError = ErrorResponseDto>(
 params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByTags>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByTags>>>, TError = ErrorResponseDto>(
 params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by tags with keyset pagination
 */

export function usePostsControllerFindByTagsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByTags>>>, TError = ErrorResponseDto>(
 params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByTagsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPostsControllerFindByTagsQueryOptions = <TData = Awaited<ReturnType<typeof postsControllerFindByTags>>, TError = ErrorResponseDto>(params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByTagsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByTags>>> = ({ signal }) => postsControllerFindByTags(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByTagsQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByTags>>>
export type PostsControllerFindByTagsQueryError = ErrorResponseDto


export function usePostsControllerFindByTags<TData = Awaited<ReturnType<typeof postsControllerFindByTags>>, TError = ErrorResponseDto>(
 params: undefined |  PostsControllerFindByTagsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByTags>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByTags<TData = Awaited<ReturnType<typeof postsControllerFindByTags>>, TError = ErrorResponseDto>(
 params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByTags>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByTags>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByTags<TData = Awaited<ReturnType<typeof postsControllerFindByTags>>, TError = ErrorResponseDto>(
 params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by tags with keyset pagination
 */

export function usePostsControllerFindByTags<TData = Awaited<ReturnType<typeof postsControllerFindByTags>>, TError = ErrorResponseDto>(
 params?: PostsControllerFindByTagsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByTags>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByTagsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get posts by author with keyset pagination
 */
export type postsControllerFindByAuthorResponse200 = {
  data: PostsControllerFindByAuthor200
  status: 200
}

export type postsControllerFindByAuthorResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type postsControllerFindByAuthorResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type postsControllerFindByAuthorResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type postsControllerFindByAuthorResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type postsControllerFindByAuthorResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type postsControllerFindByAuthorResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type postsControllerFindByAuthorResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type postsControllerFindByAuthorResponseSuccess = (postsControllerFindByAuthorResponse200) & {
  headers: Headers;
};
export type postsControllerFindByAuthorResponseError = (postsControllerFindByAuthorResponse400 | postsControllerFindByAuthorResponse401 | postsControllerFindByAuthorResponse403 | postsControllerFindByAuthorResponse404 | postsControllerFindByAuthorResponse409 | postsControllerFindByAuthorResponse422 | postsControllerFindByAuthorResponse500) & {
  headers: Headers;
};

export type postsControllerFindByAuthorResponse = (postsControllerFindByAuthorResponseSuccess | postsControllerFindByAuthorResponseError)

export const getPostsControllerFindByAuthorUrl = (authorId: string,
    params?: PostsControllerFindByAuthorParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/posts/author/${authorId}?${stringifiedParams}` : `/api/posts/author/${authorId}`
}

export const postsControllerFindByAuthor = async (authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: RequestInit): Promise<postsControllerFindByAuthorResponse> => {
  
  return clientMutator<postsControllerFindByAuthorResponse>(getPostsControllerFindByAuthorUrl(authorId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getPostsControllerFindByAuthorInfiniteQueryKey = (authorId?: string,
    params?: PostsControllerFindByAuthorParams,) => {
    return [
    'infinite', `/api/posts/author/${authorId}`, ...(params ? [params]: [])
    ] as const;
    }

export const getPostsControllerFindByAuthorQueryKey = (authorId?: string,
    params?: PostsControllerFindByAuthorParams,) => {
    return [
    `/api/posts/author/${authorId}`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getPostsControllerFindByAuthorInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>, TError = ErrorResponseDto>(authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByAuthorInfiniteQueryKey(authorId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByAuthor>>> = ({ signal }) => postsControllerFindByAuthor(authorId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(authorId),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByAuthorInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>
export type PostsControllerFindByAuthorInfiniteQueryError = ErrorResponseDto


export function usePostsControllerFindByAuthorInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>, TError = ErrorResponseDto>(
 authorId: string,
    params: undefined |  PostsControllerFindByAuthorParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByAuthorInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>, TError = ErrorResponseDto>(
 authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByAuthorInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>, TError = ErrorResponseDto>(
 authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by author with keyset pagination
 */

export function usePostsControllerFindByAuthorInfinite<TData = InfiniteData<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>, TError = ErrorResponseDto>(
 authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByAuthorInfiniteQueryOptions(authorId,params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getPostsControllerFindByAuthorQueryOptions = <TData = Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError = ErrorResponseDto>(authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPostsControllerFindByAuthorQueryKey(authorId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postsControllerFindByAuthor>>> = ({ signal }) => postsControllerFindByAuthor(authorId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(authorId),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PostsControllerFindByAuthorQueryResult = NonNullable<Awaited<ReturnType<typeof postsControllerFindByAuthor>>>
export type PostsControllerFindByAuthorQueryError = ErrorResponseDto


export function usePostsControllerFindByAuthor<TData = Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError = ErrorResponseDto>(
 authorId: string,
    params: undefined |  PostsControllerFindByAuthorParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByAuthor<TData = Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError = ErrorResponseDto>(
 authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>,
          TError,
          Awaited<ReturnType<typeof postsControllerFindByAuthor>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePostsControllerFindByAuthor<TData = Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError = ErrorResponseDto>(
 authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get posts by author with keyset pagination
 */

export function usePostsControllerFindByAuthor<TData = Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError = ErrorResponseDto>(
 authorId: string,
    params?: PostsControllerFindByAuthorParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof postsControllerFindByAuthor>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPostsControllerFindByAuthorQueryOptions(authorId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




