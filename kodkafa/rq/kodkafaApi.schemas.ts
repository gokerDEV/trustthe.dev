/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * KODKAFA API
 * Stack: Nest.js + MongoDB + Mongoose + Redis - OAuth 2.1 Compliant
 * OpenAPI spec version: 0.0.3
 */
export interface RegisterDto {
  /**
   * The name of the User
   * @minLength 5
   * @maxLength 255
   */
  name: string;
  /**
   * The password of the user.
   * @minLength 8
   * @maxLength 32
   */
  password: string;
  /**
   * The username of the User
   * @minLength 4
   * @maxLength 31
   */
  username?: string;
  /**
   * The email of the User
   * @minLength 5
   * @maxLength 255
   */
  email?: string;
  /**
   * The phone of the user
   * @minLength 12
   * @maxLength 18
   */
  phone?: string;
  /**
   * Invitation code
   * @minLength 3
   * @maxLength 60
   */
  inviteCode?: string;
}

export interface LoginDto {
  /**
   * The password of the user.
   * @minLength 8
   * @maxLength 32
   */
  password: string;
  /**
   * The username, email or sms number of the User
   * @minLength 4
   * @maxLength 255
   */
  username: string;
  /** Enable long-term login (30 days refresh token). Default: false (1 day) */
  remember?: boolean;
}

export interface OkDto {
  /** Successfull message */
  message: string;
}

export interface RecoveryDto {
  /**
   * The email of the User
   * @minLength 5
   * @maxLength 255
   */
  email?: string;
  /**
   * The phone of the user
   * @minLength 12
   * @maxLength 18
   */
  phone?: string;
}

export interface UpdatePasswordDto {
  /**
   * The password of the user.
   * @minLength 8
   * @maxLength 32
   */
  password: string;
  /**
   * The new password of the user.
   * @minLength 8
   * @maxLength 32
   */
  newPassword: string;
}

/**
 * Device information (from session)
 */
export type UserSessionDtoDevice = { [key: string]: unknown };

/**
 * Browser information (from session)
 */
export type UserSessionDtoBrowser = { [key: string]: unknown };

/**
 * Location information (from session)
 */
export type UserSessionDtoLocation = { [key: string]: unknown };

export interface UserSessionDto {
  /** Session key */
  key: string;
  /** Device information (from session) */
  device: UserSessionDtoDevice;
  /** Browser information (from session) */
  browser: UserSessionDtoBrowser;
  /** IP address (from session) */
  ip: string;
  /** Location information (from session) */
  location: UserSessionDtoLocation;
  /** Session is active */
  isActive: boolean;
  /** Session creation time */
  createdAt: string;
  /** Last used time */
  lastUsedAt: string;
}

export interface SocialUrlDto {
  /** OAuth URL for social login */
  url: string;
}

export interface SocialCallbackDto {
  /** code from the social provider */
  code: string;
  /** state from the social provider */
  state: string;
}

export interface AuthDto {
  accessToken: string;
  expiresIn: number;
}

/**
 * OAuth 2.1 grant type
 */
export type OAuthTokenRequestDtoGrantType = typeof OAuthTokenRequestDtoGrantType[keyof typeof OAuthTokenRequestDtoGrantType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthTokenRequestDtoGrantType = {
  client_credentials: 'client_credentials',
  authorization_code: 'authorization_code',
  refresh_token: 'refresh_token',
} as const;

export interface OAuthTokenRequestDto {
  /** OAuth 2.1 grant type */
  grant_type: OAuthTokenRequestDtoGrantType;
  /** Client ID (for all grant types) */
  client_id?: string;
  /** Client secret (confidential clients only, alternative to Basic Auth) */
  client_secret?: string;
  /** Authorization code (for authorization_code grant) */
  code?: string;
  /** PKCE code verifier (for authorization_code grant) */
  code_verifier?: string;
  /** Redirect URI (must match the one used in /authorize) */
  redirect_uri?: string;
  /** Refresh token (for refresh_token grant) */
  refresh_token?: string;
  /** Requested scopes (space-separated) */
  scope?: string;
}

export interface OAuthTokenResponseDto {
  /** The access token (JWT) */
  access_token: string;
  /** Token type (always "Bearer") */
  token_type: string;
  /** Token expiration time in seconds */
  expires_in: number;
  /** Refresh token (if applicable) */
  refresh_token?: string;
  /** Granted scopes (space-separated) */
  scope?: string;
}

/**
 * Error code
 */
export type OAuthErrorResponseDtoError = typeof OAuthErrorResponseDtoError[keyof typeof OAuthErrorResponseDtoError];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthErrorResponseDtoError = {
  invalid_request: 'invalid_request',
  invalid_client: 'invalid_client',
  invalid_grant: 'invalid_grant',
  unauthorized_client: 'unauthorized_client',
  unsupported_grant_type: 'unsupported_grant_type',
  invalid_scope: 'invalid_scope',
  insufficient_scope: 'insufficient_scope',
  invalid_token: 'invalid_token',
  expired_token: 'expired_token',
  attestation_required: 'attestation_required',
  attestation_failed: 'attestation_failed',
  invalid_nonce: 'invalid_nonce',
  replay_detected: 'replay_detected',
} as const;

export interface OAuthErrorResponseDto {
  /** Error code */
  error: OAuthErrorResponseDtoError;
  /** Human-readable error description */
  error_description?: string;
  /** URI with error documentation */
  error_uri?: string;
}

export interface OAuthAuthorizeResponseDto {
  /** Authorization code (single-use, 5-minute expiry) */
  code: string;
  /** State parameter (echoed back) */
  state: string;
}

/**
 * Platform (ios or android)
 */
export type OAuthAttestRequestDtoPlatform = typeof OAuthAttestRequestDtoPlatform[keyof typeof OAuthAttestRequestDtoPlatform];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthAttestRequestDtoPlatform = {
  ios: 'ios',
  android: 'android',
} as const;

export interface OAuthAttestRequestDto {
  /** Client ID of the mobile app */
  client_id: string;
  /** Platform (ios or android) */
  platform: OAuthAttestRequestDtoPlatform;
  /** Cryptographically random nonce (min 128-bit, base64url-encoded) */
  nonce: string;
  /** Platform attestation token (App Attest or Play Integrity) */
  attestation_token: string;
}

export interface OAuthAttestResponseDto {
  /** Temporary attestation token (valid for ‚â§15 minutes) */
  attestation_token: string;
  /** Token type (always "Bearer") */
  token_type: string;
  /** Expiration time in seconds */
  expires_in: number;
}

/**
 * Hint about the type of token
 */
export type OAuthIntrospectRequestDtoTokenTypeHint = typeof OAuthIntrospectRequestDtoTokenTypeHint[keyof typeof OAuthIntrospectRequestDtoTokenTypeHint];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthIntrospectRequestDtoTokenTypeHint = {
  access_token: 'access_token',
  refresh_token: 'refresh_token',
} as const;

export interface OAuthIntrospectRequestDto {
  /** The token to introspect */
  token: string;
  /** Hint about the type of token */
  token_type_hint?: OAuthIntrospectRequestDtoTokenTypeHint;
}

export interface OAuthIntrospectResponseDto {
  /** Whether the token is currently active */
  active: boolean;
  /** Scopes associated with the token (space-separated) */
  scope?: string;
  /** Client ID */
  client_id?: string;
  /** Username (email or user ID) */
  username?: string;
  /** Token type */
  token_type?: string;
  /** Expiration timestamp (Unix time) */
  exp?: number;
  /** Issued at timestamp (Unix time) */
  iat?: number;
  /** Not before timestamp (Unix time) */
  nbf?: number;
  /** Subject (user ID) */
  sub?: string;
  /** Audience */
  aud?: string;
  /** Issuer */
  iss?: string;
  /** JWT ID */
  jti?: string;
}

/**
 * Hint about the type of token
 */
export type OAuthRevokeRequestDtoTokenTypeHint = typeof OAuthRevokeRequestDtoTokenTypeHint[keyof typeof OAuthRevokeRequestDtoTokenTypeHint];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuthRevokeRequestDtoTokenTypeHint = {
  access_token: 'access_token',
  refresh_token: 'refresh_token',
} as const;

export interface OAuthRevokeRequestDto {
  /** The token to revoke */
  token: string;
  /** Hint about the type of token */
  token_type_hint?: OAuthRevokeRequestDtoTokenTypeHint;
}

/**
 * Platform identifier
 */
export type AttestRequestDtoPlatform = typeof AttestRequestDtoPlatform[keyof typeof AttestRequestDtoPlatform];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttestRequestDtoPlatform = {
  ios: 'ios',
  android: 'android',
} as const;

export interface AttestRequestDto {
  /** OAuth 2.0 Client ID (must be mobile type) */
  client_id: string;
  /** Platform identifier */
  platform: AttestRequestDtoPlatform;
  /**
   * Base64url-encoded nonce (minimum 128 bits)
   * @minLength 16
   */
  nonce: string;
  /** Platform-specific attestation token (iOS: App Attest, Android: Play Integrity) */
  attestation_token: string;
}

export interface AttestResponseDto {
  /** Short-lived attestation token for use in /oauth/token */
  attestation_token: string;
  /** Token type */
  token_type: string;
  /** Token expiry in seconds */
  expires_in: number;
}

/**
 * Response type (only "code" supported)
 */
export type PARRequestDtoResponseType = typeof PARRequestDtoResponseType[keyof typeof PARRequestDtoResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PARRequestDtoResponseType = {
  code: 'code',
} as const;

/**
 * PKCE code challenge method
 */
export type PARRequestDtoCodeChallengeMethod = typeof PARRequestDtoCodeChallengeMethod[keyof typeof PARRequestDtoCodeChallengeMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PARRequestDtoCodeChallengeMethod = {
  S256: 'S256',
} as const;

export interface PARRequestDto {
  /** Response type (only "code" supported) */
  response_type: PARRequestDtoResponseType;
  /** Client ID */
  client_id: string;
  /** Redirect URI (must be pre-registered) */
  redirect_uri: string;
  /** PKCE code challenge (optional for confidential clients) */
  code_challenge?: string;
  /** PKCE code challenge method */
  code_challenge_method?: PARRequestDtoCodeChallengeMethod;
  /** State parameter for CSRF protection (recommended) */
  state?: string;
  /** Requested scopes (space-separated) */
  scope?: string;
}

export interface PARResponseDto {
  /** Request URI to use in authorization endpoint */
  request_uri: string;
  /** Expiry time in seconds (typically 90 seconds) */
  expires_in: number;
}

/**
 * Postal address
 */
export type UserInfoResponseDtoAddress = { [key: string]: unknown };

export interface UserInfoResponseDto {
  /** Subject - unique identifier for the end-user (REQUIRED) */
  sub: string;
  /** Full name */
  name?: string;
  /** Given name(s) or first name(s) */
  given_name?: string;
  /** Surname(s) or last name(s) */
  family_name?: string;
  /** Shorthand name by which the End-User wishes to be referred */
  preferred_username?: string;
  /** Profile picture URL */
  picture?: string;
  /** Web page or blog URL */
  website?: string;
  /** Email address */
  email?: string;
  /** True if email has been verified */
  email_verified?: boolean;
  /** Phone number in E.164 format */
  phone_number?: string;
  /** True if phone number has been verified */
  phone_number_verified?: boolean;
  /** Postal address */
  address?: UserInfoResponseDtoAddress;
  /** Time when information was last updated (Unix timestamp) */
  updated_at?: number;
  /** Tenant/Project ID (multi-tenant extension) */
  tenant_id?: string;
}

/**
 * Additional context about the error
 */
export type ErrorResponseDtoContext = { [key: string]: unknown };

/**
 * Additional error details
 */
export type ErrorResponseDtoDetails = { [key: string]: unknown };

/**
 * Error category for grouping similar errors
 */
export type ErrorResponseDtoCategory = typeof ErrorResponseDtoCategory[keyof typeof ErrorResponseDtoCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseDtoCategory = {
  AUTHENTICATION: 'AUTHENTICATION',
  AUTHORIZATION: 'AUTHORIZATION',
  VALIDATION: 'VALIDATION',
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',
  RATE_LIMIT: 'RATE_LIMIT',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',
} as const;

/**
 * Error severity level
 */
export type ErrorResponseDtoSeverity = typeof ErrorResponseDtoSeverity[keyof typeof ErrorResponseDtoSeverity];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseDtoSeverity = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
} as const;

export type ErrorResponseDtoValidationsItem = {
  field?: string;
  value?: string;
  message?: string;
  code?: string;
};

export interface ErrorResponseDto {
  /** HTTP status code */
  statusCode: number;
  /** Unique error code for client-side handling */
  errorCode: string;
  /** Human-readable error message */
  message: string;
  /** ISO timestamp when the error occurred */
  timestamp: string;
  /** Request path where the error occurred */
  path?: string;
  /** HTTP method of the request */
  method?: string;
  /** Additional context about the error */
  context?: ErrorResponseDtoContext;
  /** Additional error details */
  details?: ErrorResponseDtoDetails;
  /** Error category for grouping similar errors */
  category?: ErrorResponseDtoCategory;
  /** Error severity level */
  severity?: ErrorResponseDtoSeverity;
  /** Whether the error is retryable */
  retryable?: boolean;
  /** Suggested retry delay in seconds */
  retryAfter?: number;
  /** Error documentation URL */
  documentationUrl?: string;
  /** Request correlation ID for tracking */
  correlationId?: string;
  /** Stack trace (only in development) */
  stack?: string;
  /** Validation errors (present for validation exceptions) */
  validations?: ErrorResponseDtoValidationsItem[];
  /** Underlying exception name (diagnostics only) */
  name?: string;
  /** Legacy status field aligning with statusCode */
  status?: number;
}

export type ProjectDtoScopesItem = typeof ProjectDtoScopesItem[keyof typeof ProjectDtoScopesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProjectDtoScopesItem = {
  openid: 'openid',
  profile: 'profile',
  email: 'email',
  phone: 'phone',
  address: 'address',
  'basic:read': 'basic:read',
  'basic:write': 'basic:write',
  'project:read': 'project:read',
  'project:write': 'project:write',
  'project:delete': 'project:delete',
  'apikey:read': 'apikey:read',
  'apikey:write': 'apikey:write',
  'user:read': 'user:read',
  'user:write': 'user:write',
  'user:delete': 'user:delete',
  'session:read': 'session:read',
  'session:write': 'session:write',
  'note:read': 'note:read',
  'note:write': 'note:write',
  'note:delete': 'note:delete',
  'post:read': 'post:read',
  'post:write': 'post:write',
  'post:delete': 'post:delete',
  'files:read': 'files:read',
  'files:write': 'files:write',
  'files:delete': 'files:delete',
  'profile:read': 'profile:read',
  'profile:write': 'profile:write',
  'user:email:read': 'user:email:read',
  'user:phone:read': 'user:phone:read',
  'user:address:read': 'user:address:read',
  'user:profile:read': 'user:profile:read',
  'user:profile:write': 'user:profile:write',
  'account:read': 'account:read',
  'account:write': 'account:write',
  'auth:read': 'auth:read',
  'auth:write': 'auth:write',
  'user:read:all': 'user:read:all',
  'user:write:all': 'user:write:all',
  'user:delete:all': 'user:delete:all',
  'project:users:sessions:read': 'project:users:sessions:read',
  'project:users:sessions:delete': 'project:users:sessions:delete',
  'analytics:read': 'analytics:read',
  'settings:read': 'settings:read',
  'settings:write': 'settings:write',
  'webhooks:read': 'webhooks:read',
  'webhooks:write': 'webhooks:write',
  'configuration:read': 'configuration:read',
  'configuration:write': 'configuration:write',
  'configuration:delete': 'configuration:delete',
  'communication:read': 'communication:read',
  'communication:write': 'communication:write',
  'communication:delete': 'communication:delete',
} as const;

export interface ProjectDto {
  /** The name of the project */
  name: string;
  /** The description of the project */
  description?: string;
  /** Available scopes for this project */
  scopes?: ProjectDtoScopesItem[];
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly createdBy: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
}

export type CreateProjectDtoScopesItem = typeof CreateProjectDtoScopesItem[keyof typeof CreateProjectDtoScopesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateProjectDtoScopesItem = {
  openid: 'openid',
  profile: 'profile',
  email: 'email',
  phone: 'phone',
  address: 'address',
  'basic:read': 'basic:read',
  'basic:write': 'basic:write',
  'project:read': 'project:read',
  'project:write': 'project:write',
  'project:delete': 'project:delete',
  'apikey:read': 'apikey:read',
  'apikey:write': 'apikey:write',
  'user:read': 'user:read',
  'user:write': 'user:write',
  'user:delete': 'user:delete',
  'session:read': 'session:read',
  'session:write': 'session:write',
  'note:read': 'note:read',
  'note:write': 'note:write',
  'note:delete': 'note:delete',
  'post:read': 'post:read',
  'post:write': 'post:write',
  'post:delete': 'post:delete',
  'files:read': 'files:read',
  'files:write': 'files:write',
  'files:delete': 'files:delete',
  'profile:read': 'profile:read',
  'profile:write': 'profile:write',
  'user:email:read': 'user:email:read',
  'user:phone:read': 'user:phone:read',
  'user:address:read': 'user:address:read',
  'user:profile:read': 'user:profile:read',
  'user:profile:write': 'user:profile:write',
  'account:read': 'account:read',
  'account:write': 'account:write',
  'auth:read': 'auth:read',
  'auth:write': 'auth:write',
  'user:read:all': 'user:read:all',
  'user:write:all': 'user:write:all',
  'user:delete:all': 'user:delete:all',
  'project:users:sessions:read': 'project:users:sessions:read',
  'project:users:sessions:delete': 'project:users:sessions:delete',
  'analytics:read': 'analytics:read',
  'settings:read': 'settings:read',
  'settings:write': 'settings:write',
  'webhooks:read': 'webhooks:read',
  'webhooks:write': 'webhooks:write',
  'configuration:read': 'configuration:read',
  'configuration:write': 'configuration:write',
  'configuration:delete': 'configuration:delete',
  'communication:read': 'communication:read',
  'communication:write': 'communication:write',
  'communication:delete': 'communication:delete',
} as const;

export interface CreateProjectDto {
  /** The name of the project */
  name: string;
  /** The description of the project */
  description?: string;
  /** Available scopes for this project */
  scopes?: CreateProjectDtoScopesItem[];
}

export type PageMetaDtoOrder = typeof PageMetaDtoOrder[keyof typeof PageMetaDtoOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PageMetaDtoOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export interface PageMetaDto {
  nextCursor?: string;
  prevCursor?: string;
  hasNextPage: boolean;
  hasPrevPage: boolean;
  limit: number;
  sort: string;
  order: PageMetaDtoOrder;
}

export interface ScopeItemDto {
  /** Scope value */
  value: string;
  /** Scope label */
  label: string;
  /** Scope description */
  description: string;
}

export interface ScopeListDto {
  /** List of available scopes */
  scopes: ScopeItemDto[];
}

export interface MemberRoleItemDto {
  /** Role value */
  value: string;
  /** Role label */
  label: string;
  /** Role description */
  description: string;
}

export interface MemberRoleListDto {
  /** List of available member roles */
  roles: MemberRoleItemDto[];
}

export type UpdateProjectDtoScopesItem = typeof UpdateProjectDtoScopesItem[keyof typeof UpdateProjectDtoScopesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateProjectDtoScopesItem = {
  openid: 'openid',
  profile: 'profile',
  email: 'email',
  phone: 'phone',
  address: 'address',
  'basic:read': 'basic:read',
  'basic:write': 'basic:write',
  'project:read': 'project:read',
  'project:write': 'project:write',
  'project:delete': 'project:delete',
  'apikey:read': 'apikey:read',
  'apikey:write': 'apikey:write',
  'user:read': 'user:read',
  'user:write': 'user:write',
  'user:delete': 'user:delete',
  'session:read': 'session:read',
  'session:write': 'session:write',
  'note:read': 'note:read',
  'note:write': 'note:write',
  'note:delete': 'note:delete',
  'post:read': 'post:read',
  'post:write': 'post:write',
  'post:delete': 'post:delete',
  'files:read': 'files:read',
  'files:write': 'files:write',
  'files:delete': 'files:delete',
  'profile:read': 'profile:read',
  'profile:write': 'profile:write',
  'user:email:read': 'user:email:read',
  'user:phone:read': 'user:phone:read',
  'user:address:read': 'user:address:read',
  'user:profile:read': 'user:profile:read',
  'user:profile:write': 'user:profile:write',
  'account:read': 'account:read',
  'account:write': 'account:write',
  'auth:read': 'auth:read',
  'auth:write': 'auth:write',
  'user:read:all': 'user:read:all',
  'user:write:all': 'user:write:all',
  'user:delete:all': 'user:delete:all',
  'project:users:sessions:read': 'project:users:sessions:read',
  'project:users:sessions:delete': 'project:users:sessions:delete',
  'analytics:read': 'analytics:read',
  'settings:read': 'settings:read',
  'settings:write': 'settings:write',
  'webhooks:read': 'webhooks:read',
  'webhooks:write': 'webhooks:write',
  'configuration:read': 'configuration:read',
  'configuration:write': 'configuration:write',
  'configuration:delete': 'configuration:delete',
  'communication:read': 'communication:read',
  'communication:write': 'communication:write',
  'communication:delete': 'communication:delete',
} as const;

export interface UpdateProjectDto {
  /** The name of the project */
  name?: string;
  /** The description of the project */
  description?: string;
  /** Available scopes for this project */
  scopes?: UpdateProjectDtoScopesItem[];
}

export interface ObjectId { [key: string]: unknown }

/**
 * Role to assign to the member
 */
export type AddMemberDtoRole = typeof AddMemberDtoRole[keyof typeof AddMemberDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddMemberDtoRole = {
  owner: 'owner',
  admin: 'admin',
  member: 'member',
  viewer: 'viewer',
} as const;

export interface AddMemberDto {
  /** User ID to add as a project member */
  userId: ObjectId;
  /** Role to assign to the member */
  role: AddMemberDtoRole;
  /** Specific permissions/scopes to assign to the member */
  permissions?: string[];
}

/**
 * New role for the member
 */
export type ChangeMemberRoleDtoRole = typeof ChangeMemberRoleDtoRole[keyof typeof ChangeMemberRoleDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChangeMemberRoleDtoRole = {
  owner: 'owner',
  admin: 'admin',
  member: 'member',
  viewer: 'viewer',
} as const;

export interface ChangeMemberRoleDto {
  /** New role for the member */
  role: ChangeMemberRoleDtoRole;
  /** Updated permissions/scopes for the member */
  permissions?: string[];
}

/**
 * Client type (determines grant types and fields)
 */
export type CreateApiKeyDtoType = typeof CreateApiKeyDtoType[keyof typeof CreateApiKeyDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateApiKeyDtoType = {
  confidential: 'confidential',
  mobile: 'mobile',
} as const;

export interface CreateApiKeyDto {
  /** Name of the API key */
  name: string;
  /** Client type (determines grant types and fields) */
  type: CreateApiKeyDtoType;
  /** Scopes assigned to this API key */
  scopes: string[];
  /** Allowed redirect URIs. Required for mobile; optional for confidential. */
  callbackUrls: string[];
  /** Description of the API key */
  description: string;
}

/**
 * Client type (determines grant types and fields)
 */
export type ApiKeyType = typeof ApiKeyType[keyof typeof ApiKeyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiKeyType = {
  confidential: 'confidential',
  mobile: 'mobile',
} as const;

export interface ApiKey {
  /** Name of the API key */
  name: string;
  /** Client type (determines grant types and fields) */
  type: ApiKeyType;
  /** Public client identifier */
  clientId: string;
  /** BCrypt/Argon2 hash of client_secret (confidential only). Not returned in APIs. */
  secretHash?: string;
  /**
   * Project ID this key belongs to
   * @minLength 24
   * @maxLength 24
   */
  projectId: string;
  /** Scopes assigned to this API key */
  scopes: string[];
  /** Allowed redirect URIs. Required for mobile; optional for confidential. */
  callbackUrls: string[];
  /** Description of the API key */
  description: string;
  /** Whether the API key is active */
  isActive: boolean;
  /** Keyset generation number for rotation */
  keysetGeneration?: number;
  /**
   * The unique id of the creator
   * @minLength 24
   * @maxLength 24
   */
  readonly createdBy: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
}

/**
 * Client type (determines grant types and fields)
 */
export type ApiKeyDtoType = typeof ApiKeyDtoType[keyof typeof ApiKeyDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiKeyDtoType = {
  confidential: 'confidential',
  mobile: 'mobile',
} as const;

export interface ApiKeyDto {
  /** Name of the API key */
  name: string;
  /** Client type (determines grant types and fields) */
  type: ApiKeyDtoType;
  /** Public client identifier */
  clientId: string;
  /**
   * Project ID this key belongs to
   * @minLength 24
   * @maxLength 24
   */
  projectId: string;
  /** Scopes assigned to this API key */
  scopes: string[];
  /** Allowed redirect URIs. Required for mobile; optional for confidential. */
  callbackUrls: string[];
  /** Description of the API key */
  description: string;
  /** Whether the API key is active */
  isActive: boolean;
  /** Keyset generation number for rotation */
  keysetGeneration?: number;
  /**
   * The unique id of the creator
   * @minLength 24
   * @maxLength 24
   */
  readonly createdBy: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
}

export interface UpdateApiKeyDto {
  /** Name of the API key */
  name: string;
  /** Scopes assigned to this API key */
  scopes: string[];
  /** Allowed redirect URIs. Required for mobile; optional for confidential. */
  callbackUrls: string[];
  /** Description of the API key */
  description: string;
  /** Whether the API key is active */
  isActive: boolean;
  /** Keyset generation number for rotation */
  keysetGeneration?: number;
}

export interface AddAccountDto {
  provider: string;
  identity: string;
  isVerified: boolean;
  /** Whether this account is the primary account for the user */
  isPrimary: boolean;
}

export interface AccountDto {
  provider: string;
  identity: string;
  isVerified: boolean;
  /** Whether this account is the primary account for the user */
  isPrimary: boolean;
}

export type PaginationDtoFilter = { [key: string]: unknown };

export interface PaginationDto {
  /** Cursor for the next page of results */
  cursor?: ObjectId;
  /** Number of items to load (max: 100) */
  limit?: number;
  sort?: string;
  filter?: PaginationDtoFilter;
  search?: string;
  status?: string;
}

export interface ResponseStatusDto {
  /** Response status as boolean */
  status: boolean;
}

export interface Account {
  provider: string;
  identity: string;
  isVerified: boolean;
  /** Whether this account is the primary account for the user */
  isPrimary: boolean;
}

export interface CreateUserDto {
  /**
   * The name of the User
   * @minLength 5
   * @maxLength 255
   */
  name?: string;
  /**
   * The password of the user.
   * @minLength 8
   * @maxLength 32
   */
  password?: string;
  /**
   * The username of the User
   * @minLength 4
   * @maxLength 31
   */
  username?: string;
  /**
   * The email of the User
   * @minLength 5
   * @maxLength 255
   */
  email?: string;
  /**
   * The phone of the user
   * @minLength 12
   * @maxLength 18
   */
  phone?: string;
  /**
   * Invitation code
   * @minLength 3
   * @maxLength 60
   */
  inviteCode?: string;
  /**
   * Project ID
   * @minLength 24
   * @maxLength 24
   */
  project: string;
  /** Determines user is verified or not. */
  isVerified: boolean;
  /** User accounts */
  accounts: Account[];
}

export interface ResponseIdDto {
  /** Response id as string */
  id: string;
}

export interface UserDto {
  /**
   * Project ID this user belongs to
   * @minLength 24
   * @maxLength 24
   */
  projectId: string;
  /**
   * The name of the User
   * @minLength 5
   * @maxLength 255
   */
  name: string;
  accounts: Account[];
  /** All scopes of the user. */
  scopes: string[];
  /** Determines user is verified or not. */
  isVerified: boolean;
  /** It corresponds user is active or not. */
  isDeactivated: boolean;
  createdAt: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
}

export interface UpdateUserDto {
  /**
   * Project ID this user belongs to
   * @minLength 24
   * @maxLength 24
   */
  projectId?: string;
  /**
   * The name of the User
   * @minLength 5
   * @maxLength 255
   */
  name?: string;
  accounts?: Account[];
  /**
   * The password of the user.
   * @minLength 8
   * @maxLength 32
   */
  password?: string;
  /** All scopes of the user. */
  scopes?: string[];
  /** Determines user is verified or not. */
  isVerified?: boolean;
  /** It corresponds user is active or not. */
  isDeactivated?: boolean;
  createdAt?: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id?: string;
}

export interface UpdateUserScopesDto {
  /** All scopes of the user. */
  scopes: string[];
}

export interface InviteDto {
  /** Email address of the user to invite */
  email: string;
  /** Name of the user to invite */
  name?: string;
  /** Custom invitation message */
  message?: string;
}

/**
 * Invitation status
 */
export type InvitationDtoStatus = typeof InvitationDtoStatus[keyof typeof InvitationDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvitationDtoStatus = {
  draft: 'draft',
  hidden: 'hidden',
  pending: 'pending',
  scheduled: 'scheduled',
  paused: 'paused',
  active: 'active',
  completed: 'completed',
  published: 'published',
  cancelled: 'cancelled',
  expired: 'expired',
  accepted: 'accepted',
  rejected: 'rejected',
} as const;

export interface InvitationDto {
  /** Invitation ID (token) */
  invitationId: string;
  /** Email address of the invited user */
  email: string;
  /** Invitation status */
  status: InvitationDtoStatus;
  /** Invitation creation date */
  createdAt: string;
  /** Invitation expiration date */
  expiresAt: string;
  /** User ID who sent the invitation */
  invitedBy: string;
}

export interface CountDto {
  /** Count value */
  count: number;
}

/**
 * Type of OTP operation
 */
export type CreateOtpDtoType = typeof CreateOtpDtoType[keyof typeof CreateOtpDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateOtpDtoType = {
  invite: 'invite',
  verify: 'verify',
  recovery: 'recovery',
  discount: 'discount',
  reset_password: 'reset_password',
} as const;

export interface CreateOtpDto {
  /**
   * The identifier for OTP (email, phone, userId, etc.)
   * @minLength 1
   * @maxLength 100
   */
  identifier: string;
  /** Associated token or payload */
  token: string;
  /** Type of OTP operation */
  type: CreateOtpDtoType;
}

export interface CreateOtpResponseDto {
  /** Success message */
  message: string;
}

/**
 * Type of OTP operation
 */
export type ResendOtpDtoType = typeof ResendOtpDtoType[keyof typeof ResendOtpDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResendOtpDtoType = {
  invite: 'invite',
  verify: 'verify',
  recovery: 'recovery',
  discount: 'discount',
  reset_password: 'reset_password',
} as const;

export interface ResendOtpDto {
  /** The identifier for OTP (email, phone, userId, etc.) */
  identifier: string;
  /** Type of OTP operation */
  type: ResendOtpDtoType;
}

/**
 * Type of OTP operation
 */
export type VerifyOtpDtoType = typeof VerifyOtpDtoType[keyof typeof VerifyOtpDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerifyOtpDtoType = {
  invite: 'invite',
  verify: 'verify',
  recovery: 'recovery',
  discount: 'discount',
  reset_password: 'reset_password',
} as const;

export interface VerifyOtpDto {
  /** The identifier for OTP (email, phone, userId, etc.) */
  identifier: string;
  /**
   * 6-character OTP code
   * @minLength 6
   * @maxLength 6
   */
  code: string;
  /** Type of OTP operation */
  type: VerifyOtpDtoType;
}

export interface VerifyOtpResponseDto {
  /** The verified token */
  token: string;
  /** Success message */
  message: string;
}

/**
 * Communication purpose
 */
export type CreateCommunicationTemplateDtoPurpose = typeof CreateCommunicationTemplateDtoPurpose[keyof typeof CreateCommunicationTemplateDtoPurpose];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateCommunicationTemplateDtoPurpose = {
  invite: 'invite',
  verify: 'verify',
  recovery: 'recovery',
  discount: 'discount',
  reset_password: 'reset_password',
  welcome: 'welcome',
  notification: 'notification',
  alert: 'alert',
  reminder: 'reminder',
  promotion: 'promotion',
  newsletter: 'newsletter',
  announcement: 'announcement',
} as const;

/**
 * Communication channel
 */
export type CreateCommunicationTemplateDtoChannel = typeof CreateCommunicationTemplateDtoChannel[keyof typeof CreateCommunicationTemplateDtoChannel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateCommunicationTemplateDtoChannel = {
  email: 'email',
  sms: 'sms',
  push: 'push',
  webhook: 'webhook',
  slack: 'slack',
  discord: 'discord',
  telegram: 'telegram',
} as const;

export interface CreateCommunicationTemplateDto {
  /** Communication purpose */
  purpose: CreateCommunicationTemplateDtoPurpose;
  /** Communication channel */
  channel: CreateCommunicationTemplateDtoChannel;
  /** Template title */
  title: string;
  /** Rendered content (Handlebars template) */
  rendered: string;
  /** Plain text content (Handlebars template) */
  textTemplate: string;
  /** Template description */
  description?: string;
  /** Whether this template is active */
  isActive?: boolean;
}

/**
 * Project ID (null for system templates)
 * @nullable
 */
export type CommunicationTemplateResponseDtoProjectId = ObjectId | null;

/**
 * Communication purpose
 */
export type CommunicationTemplateResponseDtoPurpose = typeof CommunicationTemplateResponseDtoPurpose[keyof typeof CommunicationTemplateResponseDtoPurpose];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CommunicationTemplateResponseDtoPurpose = {
  invite: 'invite',
  verify: 'verify',
  recovery: 'recovery',
  discount: 'discount',
  reset_password: 'reset_password',
  welcome: 'welcome',
  notification: 'notification',
  alert: 'alert',
  reminder: 'reminder',
  promotion: 'promotion',
  newsletter: 'newsletter',
  announcement: 'announcement',
} as const;

/**
 * Communication channel
 */
export type CommunicationTemplateResponseDtoChannel = typeof CommunicationTemplateResponseDtoChannel[keyof typeof CommunicationTemplateResponseDtoChannel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CommunicationTemplateResponseDtoChannel = {
  email: 'email',
  sms: 'sms',
  push: 'push',
  webhook: 'webhook',
  slack: 'slack',
  discord: 'discord',
  telegram: 'telegram',
} as const;

export interface CommunicationTemplateResponseDto {
  /** The unique id */
  id: string;
  /**
   * Project ID (null for system templates)
   * @nullable
   */
  projectId: CommunicationTemplateResponseDtoProjectId;
  /** Communication purpose */
  purpose: CommunicationTemplateResponseDtoPurpose;
  /** Communication channel */
  channel: CommunicationTemplateResponseDtoChannel;
  /** Template title */
  title: string;
  /** Rendered content (Handlebars template) */
  rendered: string;
  /** Plain text content (Handlebars template) */
  textTemplate: string;
  /** Template description */
  description?: string;
  /** Whether this template is active */
  isActive: boolean;
  /** User who created the template */
  createdBy: string;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt: string;
}

export interface UpdateCommunicationTemplateDto {
  /** Template title */
  title?: string;
  /** Rendered content (Handlebars template) */
  rendered?: string;
  /** Plain text content (Handlebars template) */
  textTemplate?: string;
  /** Template description */
  description?: string;
  /** Whether this template is active */
  isActive?: boolean;
}

export interface ConfigurationListResponseDto {
  /** Configuration ID */
  id: string;
  /** Configuration category */
  category: string;
  /** Configuration provider */
  provider: string;
  /** Configuration label (optional) */
  label?: string;
  /** Whether this configuration is active */
  isActive: boolean;
  /** Provider display name */
  providerName: string;
  /** Provider description */
  providerDescription: string;
  /** Whether this configuration uses encryption */
  isEncrypted: boolean;
}

/**
 * Configuration category
 */
export type SaveConfigurationDtoCategory = typeof SaveConfigurationDtoCategory[keyof typeof SaveConfigurationDtoCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SaveConfigurationDtoCategory = {
  tenant: 'tenant',
  mail: 'mail',
  sms: 'sms',
  storage: 'storage',
  oauth: 'oauth',
  attestation: 'attestation',
} as const;

/**
 * Configuration data (structure depends on provider)
 */
export type SaveConfigurationDtoConfig = { [key: string]: unknown };

export interface SaveConfigurationDto {
  /** Configuration category */
  category: SaveConfigurationDtoCategory;
  /** Provider/service name */
  provider: string;
  /** Configuration label (for multiple configs of same provider) */
  label?: string;
  /** Whether this configuration is active */
  isActive: boolean;
  /** Configuration data (structure depends on provider) */
  config: SaveConfigurationDtoConfig;
}

/**
 * Configuration category
 */
export type ConfigurationResponseDtoCategory = typeof ConfigurationResponseDtoCategory[keyof typeof ConfigurationResponseDtoCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConfigurationResponseDtoCategory = {
  tenant: 'tenant',
  mail: 'mail',
  sms: 'sms',
  storage: 'storage',
  oauth: 'oauth',
  attestation: 'attestation',
} as const;

/**
 * Configuration data (provider-specific)
 */
export type ConfigurationResponseDtoConfig = { [key: string]: unknown };

export interface ConfigurationResponseDto {
  /** Configuration ID */
  id: string;
  /** Configuration category */
  category: ConfigurationResponseDtoCategory;
  /** Configuration provider */
  provider: string;
  /** Configuration label (optional) */
  label?: string;
  /** Whether this configuration is active */
  isActive: boolean;
  /** Configuration data (provider-specific) */
  config: ConfigurationResponseDtoConfig;
  /** Provider display name */
  providerName: string;
  /** Provider description */
  providerDescription: string;
  /** Whether this configuration uses encryption */
  isEncrypted: boolean;
  /** Configuration creation date */
  createdAt: string;
  /** Configuration last update date */
  updatedAt: string;
}

/**
 * Configuration data (structure depends on provider)
 */
export type UpdateConfigurationDtoConfig = { [key: string]: unknown };

export interface UpdateConfigurationDto {
  /** Configuration label (for multiple configs of same provider) */
  label?: string;
  /** Whether this configuration is active */
  isActive: boolean;
  /** Configuration data (structure depends on provider) */
  config: UpdateConfigurationDtoConfig;
}

export interface Exif {
  Model: string;
  Lens: string;
  ISOSpeedRatings: string;
  FocalLength: string;
  FNumber: string;
  ExposureTime: string;
  WhiteBalance: string;
  MeteringMode: string;
  DateTime: string;
  GPSLatitude: string;
  GPSLongitude: string;
}

export interface Point {
  type: string;
  coordinates: number[];
}

export interface PostFileDto {
  altText: string;
  exif?: Exif;
  location?: Point;
  src: string;
  type: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
}

export interface AuthorDto {
  /**
   * The unique id of the author
   * @minLength 24
   * @maxLength 24
   */
  id: string;
  /** Author name */
  name: string;
  /** Author username (falls back to userId if username not found) */
  username?: string;
}

export interface CategoryDto {
  /** The unique id */
  readonly id: string;
  /** Category slug */
  readonly slug: string;
  /** Category title */
  readonly title: string;
}

export type PostDtoType = typeof PostDtoType[keyof typeof PostDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostDtoType = {
  category: 'category',
  post: 'post',
  article: 'article',
} as const;

export type PostDtoStatus = typeof PostDtoStatus[keyof typeof PostDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostDtoStatus = {
  draft: 'draft',
  hidden: 'hidden',
  pending: 'pending',
  scheduled: 'scheduled',
  paused: 'paused',
  active: 'active',
  completed: 'completed',
  published: 'published',
  cancelled: 'cancelled',
  expired: 'expired',
  accepted: 'accepted',
  rejected: 'rejected',
} as const;

export interface PostDto {
  readonly createdAt: string;
  readonly updatedAt: string;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  projectId: string;
  /**
   * Domain label for multi-site support (e.g., "main-website", "blog-subsite")
   * @maxLength 30
   */
  domain: string;
  /**
   * @minLength 5
   * @maxLength 120
   */
  title: string;
  /**
   * @minLength 5
   * @maxLength 120
   */
  slug: string;
  /**
   * @minLength 10
   * @maxLength 500
   */
  description?: string;
  content?: string;
  tags?: string[];
  type?: PostDtoType;
  status?: PostDtoStatus;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
  /**
   * The unique id of the author
   * @minLength 24
   * @maxLength 24
   */
  authorId: string;
  /** Post files (origin field excluded) */
  files?: PostFileDto[];
  /** Post author information (populated) */
  readonly author?: AuthorDto;
  /** Post categories (populated) */
  readonly categories?: readonly CategoryDto[];
}

export interface PostSitemapDto {
  /** The unique id */
  readonly id: string;
  /** Domain label for multi-site support */
  domain: string;
  /** Post slug for URL construction */
  slug: string;
  /** Last modification date for sitemap lastmod */
  updatedAt: string;
}

export interface UpdatePostFileDto {
  altText: string;
  location?: Point;
}

export interface TagCloudDto {
  name: string;
  usage: number;
}

export type CreatePostDtoType = typeof CreatePostDtoType[keyof typeof CreatePostDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreatePostDtoType = {
  category: 'category',
  post: 'post',
  article: 'article',
} as const;

export type CreatePostDtoStatus = typeof CreatePostDtoStatus[keyof typeof CreatePostDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreatePostDtoStatus = {
  draft: 'draft',
  hidden: 'hidden',
  pending: 'pending',
  scheduled: 'scheduled',
  paused: 'paused',
  active: 'active',
  completed: 'completed',
  published: 'published',
  cancelled: 'cancelled',
  expired: 'expired',
  accepted: 'accepted',
  rejected: 'rejected',
} as const;

export interface CreatePostDto {
  /**
   * Domain label for multi-site support (e.g., "main-website", "blog-subsite")
   * @maxLength 30
   */
  domain: string;
  categories: string[];
  /**
   * @minLength 5
   * @maxLength 120
   */
  title: string;
  /**
   * @minLength 5
   * @maxLength 120
   */
  slug: string;
  /**
   * @minLength 10
   * @maxLength 500
   */
  description?: string;
  tags?: string[];
  type?: CreatePostDtoType;
  status?: CreatePostDtoStatus;
}

export interface UpdateFileDto {
  altText: string;
  location?: Point;
  /**
   * The unique id
   * @minLength 24
   * @maxLength 24
   */
  readonly id: string;
}

export type UpdatePostDtoType = typeof UpdatePostDtoType[keyof typeof UpdatePostDtoType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdatePostDtoType = {
  category: 'category',
  post: 'post',
  article: 'article',
} as const;

export type UpdatePostDtoStatus = typeof UpdatePostDtoStatus[keyof typeof UpdatePostDtoStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdatePostDtoStatus = {
  draft: 'draft',
  hidden: 'hidden',
  pending: 'pending',
  scheduled: 'scheduled',
  paused: 'paused',
  active: 'active',
  completed: 'completed',
  published: 'published',
  cancelled: 'cancelled',
  expired: 'expired',
  accepted: 'accepted',
  rejected: 'rejected',
} as const;

export interface UpdatePostDto {
  /**
   * Domain label for multi-site support (e.g., "main-website", "blog-subsite")
   * @maxLength 30
   */
  domain?: string;
  /**
   * @minLength 5
   * @maxLength 120
   */
  title?: string;
  /**
   * @minLength 5
   * @maxLength 120
   */
  slug?: string;
  /**
   * @minLength 10
   * @maxLength 500
   */
  description?: string;
  content?: string;
  tags?: string[];
  type?: UpdatePostDtoType;
  status?: UpdatePostDtoStatus;
  categories: string[];
  files?: UpdateFileDto[];
}

export interface OpenAIFileRefDto {
  /** The name of the file */
  name: string;
  /** A stable identifier for the file */
  id: string;
  /** The mime type of the file */
  mime_type: string;
  /** The URL to fetch the file which is valid for five minutes */
  download_link: string;
}

export interface OpenAIFileUploadDto {
  /** Array of OpenAI file references */
  files: OpenAIFileRefDto[];
}

export type AuthControllerRegister201 = {
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_in?: number;
};

export type AuthControllerLogin200 = {
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_in?: number;
};

export type AuthControllerRefresh200 = {
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_in?: number;
};

export type AuthControllerResetPasswordBody = {
  /** The recovery token sent to the user. */
  token?: string;
  /** The new password. */
  password?: string;
};

export type AuthControllerResetPassword200 = {
  access_token?: string;
  refresh_token?: string;
  token_type?: string;
  expires_in?: number;
};

export type AuthorizeControllerAuthorizeParams = {
/**
 * PAR request URI (RFC 9126)
 */
request_uri?: string;
/**
 * Response type (only "code" supported)
 */
response_type?: AuthorizeControllerAuthorizeResponseType;
/**
 * Client ID
 */
client_id?: string;
/**
 * Redirect URI (must be pre-registered)
 */
redirect_uri?: string;
/**
 * PKCE code challenge
 */
code_challenge?: string;
/**
 * PKCE code challenge method (only S256 supported)
 */
code_challenge_method?: AuthorizeControllerAuthorizeCodeChallengeMethod;
/**
 * State parameter for CSRF protection (mandatory for direct requests)
 */
state?: string;
/**
 * Requested scopes (space-separated)
 */
scope?: string;
};

export type AuthorizeControllerAuthorizeResponseType = typeof AuthorizeControllerAuthorizeResponseType[keyof typeof AuthorizeControllerAuthorizeResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthorizeControllerAuthorizeResponseType = {
  code: 'code',
} as const;

export type AuthorizeControllerAuthorizeCodeChallengeMethod = typeof AuthorizeControllerAuthorizeCodeChallengeMethod[keyof typeof AuthorizeControllerAuthorizeCodeChallengeMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthorizeControllerAuthorizeCodeChallengeMethod = {
  S256: 'S256',
} as const;

export type DiscoveryControllerGetAuthorizationServerMetadata200 = {
  issuer?: string;
  authorization_endpoint?: string;
  token_endpoint?: string;
  token_endpoint_auth_methods_supported?: string[];
  introspection_endpoint?: string;
  introspection_endpoint_auth_methods_supported?: string[];
  revocation_endpoint?: string;
  revocation_endpoint_auth_methods_supported?: string[];
  jwks_uri?: string;
  response_types_supported?: string[];
  response_modes_supported?: string[];
  grant_types_supported?: string[];
  code_challenge_methods_supported?: string[];
  scopes_supported?: string[];
  service_documentation?: string;
  ui_locales_supported?: string[];
};

export type DiscoveryControllerGetJWKS200KeysItem = {
  kty?: string;
  use?: string;
  kid?: string;
  alg?: string;
  n?: string;
  e?: string;
};

export type DiscoveryControllerGetJWKS200 = {
  keys?: DiscoveryControllerGetJWKS200KeysItem[];
};

export type ProjectsCrudControllerFindAll200 = {
  items?: ProjectDto[];
  meta?: PageMetaDto;
};

export type UsersAccountsControllerFindParams = {
provider: string;
identity: string;
isVerified: boolean;
/**
 * Whether this account is the primary account for the user
 */
isPrimary: boolean;
};

export type PostsQueryControllerFindAllParams = {
/**
 * Number of items to return (1-100, default: 20)
 */
limit?: number;
/**
 * Cursor token for next page (forward pagination)
 */
after?: string;
/**
 * Cursor token for previous page (backward pagination)
 */
before?: string;
/**
 * Sort field with optional '-' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt
 */
sort?: PostsQueryControllerFindAllSort;
/**
 * Filter by projectId
 */
projectId?: string;
/**
 * Filter by domain (exact match)
 */
domain?: string;
/**
 * Filter where domain contains the value (case-sensitive)
 */
'domain.contains'?: string;
/**
 * Filter where domain contains the value (case-insensitive)
 */
'domain.icontains'?: string;
/**
 * Filter where domain starts with the value (case-sensitive)
 */
'domain.startsWith'?: string;
/**
 * Filter where domain starts with the value (case-insensitive)
 */
'domain.istartswith'?: string;
/**
 * Filter by title (exact match)
 */
title?: string;
/**
 * Filter where title contains the value (case-sensitive)
 */
'title.contains'?: string;
/**
 * Filter where title contains the value (case-insensitive)
 */
'title.icontains'?: string;
/**
 * Filter where title starts with the value (case-sensitive)
 */
'title.startsWith'?: string;
/**
 * Filter where title starts with the value (case-insensitive)
 */
'title.istartswith'?: string;
/**
 * Filter by slug (exact match)
 */
slug?: string;
/**
 * Filter where slug contains the value (case-sensitive)
 */
'slug.contains'?: string;
/**
 * Filter where slug contains the value (case-insensitive)
 */
'slug.icontains'?: string;
/**
 * Filter where slug starts with the value (case-sensitive)
 */
'slug.startsWith'?: string;
/**
 * Filter where slug starts with the value (case-insensitive)
 */
'slug.istartswith'?: string;
/**
 * Filter by description (exact match)
 */
description?: string;
/**
 * Filter where description contains the value (case-sensitive)
 */
'description.contains'?: string;
/**
 * Filter where description contains the value (case-insensitive)
 */
'description.icontains'?: string;
/**
 * Filter where description starts with the value (case-sensitive)
 */
'description.startsWith'?: string;
/**
 * Filter where description starts with the value (case-insensitive)
 */
'description.istartswith'?: string;
/**
 * Filter by tags (exact match)
 */
tags?: string;
/**
 * Filter where tags contains the value (case-sensitive)
 */
'tags.contains'?: string;
/**
 * Filter where tags contains the value (case-insensitive)
 */
'tags.icontains'?: string;
/**
 * Filter where tags starts with the value (case-sensitive)
 */
'tags.startsWith'?: string;
/**
 * Filter where tags starts with the value (case-insensitive)
 */
'tags.istartswith'?: string;
/**
 * Filter by type (exact match)
 */
type?: string;
/**
 * Filter where type contains the value (case-sensitive)
 */
'type.contains'?: string;
/**
 * Filter where type contains the value (case-insensitive)
 */
'type.icontains'?: string;
/**
 * Filter where type starts with the value (case-sensitive)
 */
'type.startsWith'?: string;
/**
 * Filter where type starts with the value (case-insensitive)
 */
'type.istartswith'?: string;
/**
 * Filter by status (exact match)
 */
status?: string;
/**
 * Filter where status contains the value (case-sensitive)
 */
'status.contains'?: string;
/**
 * Filter where status contains the value (case-insensitive)
 */
'status.icontains'?: string;
/**
 * Filter where status starts with the value (case-sensitive)
 */
'status.startsWith'?: string;
/**
 * Filter where status starts with the value (case-insensitive)
 */
'status.istartswith'?: string;
/**
 * Filter by authorId
 */
authorId?: string;
/**
 * Filter by categories
 */
categories?: string;
/**
 * Filter by createdAt (exact match, ISO date string for dates)
 */
createdAt?: string;
/**
 * Filter where createdAt is greater than
 */
'createdAt.gt'?: string;
/**
 * Filter where createdAt is greater than or equal
 */
'createdAt.gte'?: string;
/**
 * Filter where createdAt is less than
 */
'createdAt.lt'?: string;
/**
 * Filter where createdAt is less than or equal
 */
'createdAt.lte'?: string;
/**
 * Filter by updatedAt (exact match, ISO date string for dates)
 */
updatedAt?: string;
/**
 * Filter where updatedAt is greater than
 */
'updatedAt.gt'?: string;
/**
 * Filter where updatedAt is greater than or equal
 */
'updatedAt.gte'?: string;
/**
 * Filter where updatedAt is less than
 */
'updatedAt.lt'?: string;
/**
 * Filter where updatedAt is less than or equal
 */
'updatedAt.lte'?: string;
};

export type PostsQueryControllerFindAllSort = typeof PostsQueryControllerFindAllSort[keyof typeof PostsQueryControllerFindAllSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostsQueryControllerFindAllSort = {
  title: 'title',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  '-title': '-title',
  '-slug': '-slug',
  '-createdAt': '-createdAt',
  '-updatedAt': '-updatedAt',
} as const;

export type PostsQueryControllerFindAll200 = {
  items?: PostDto[];
  meta?: PageMetaDto;
};

export type PostsQueryControllerFindSitemapParams = {
/**
 * Number of items to return (1-100, default: 20)
 */
limit?: number;
/**
 * Cursor token for next page (forward pagination)
 */
after?: string;
/**
 * Cursor token for previous page (backward pagination)
 */
before?: string;
/**
 * Sort field with optional '-' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt
 */
sort?: PostsQueryControllerFindSitemapSort;
/**
 * Filter by projectId
 */
projectId?: string;
/**
 * Filter by domain (exact match)
 */
domain?: string;
/**
 * Filter where domain contains the value (case-sensitive)
 */
'domain.contains'?: string;
/**
 * Filter where domain contains the value (case-insensitive)
 */
'domain.icontains'?: string;
/**
 * Filter where domain starts with the value (case-sensitive)
 */
'domain.startsWith'?: string;
/**
 * Filter where domain starts with the value (case-insensitive)
 */
'domain.istartswith'?: string;
/**
 * Filter by title (exact match)
 */
title?: string;
/**
 * Filter where title contains the value (case-sensitive)
 */
'title.contains'?: string;
/**
 * Filter where title contains the value (case-insensitive)
 */
'title.icontains'?: string;
/**
 * Filter where title starts with the value (case-sensitive)
 */
'title.startsWith'?: string;
/**
 * Filter where title starts with the value (case-insensitive)
 */
'title.istartswith'?: string;
/**
 * Filter by slug (exact match)
 */
slug?: string;
/**
 * Filter where slug contains the value (case-sensitive)
 */
'slug.contains'?: string;
/**
 * Filter where slug contains the value (case-insensitive)
 */
'slug.icontains'?: string;
/**
 * Filter where slug starts with the value (case-sensitive)
 */
'slug.startsWith'?: string;
/**
 * Filter where slug starts with the value (case-insensitive)
 */
'slug.istartswith'?: string;
/**
 * Filter by description (exact match)
 */
description?: string;
/**
 * Filter where description contains the value (case-sensitive)
 */
'description.contains'?: string;
/**
 * Filter where description contains the value (case-insensitive)
 */
'description.icontains'?: string;
/**
 * Filter where description starts with the value (case-sensitive)
 */
'description.startsWith'?: string;
/**
 * Filter where description starts with the value (case-insensitive)
 */
'description.istartswith'?: string;
/**
 * Filter by tags (exact match)
 */
tags?: string;
/**
 * Filter where tags contains the value (case-sensitive)
 */
'tags.contains'?: string;
/**
 * Filter where tags contains the value (case-insensitive)
 */
'tags.icontains'?: string;
/**
 * Filter where tags starts with the value (case-sensitive)
 */
'tags.startsWith'?: string;
/**
 * Filter where tags starts with the value (case-insensitive)
 */
'tags.istartswith'?: string;
/**
 * Filter by type (exact match)
 */
type?: string;
/**
 * Filter where type contains the value (case-sensitive)
 */
'type.contains'?: string;
/**
 * Filter where type contains the value (case-insensitive)
 */
'type.icontains'?: string;
/**
 * Filter where type starts with the value (case-sensitive)
 */
'type.startsWith'?: string;
/**
 * Filter where type starts with the value (case-insensitive)
 */
'type.istartswith'?: string;
/**
 * Filter by status (exact match)
 */
status?: string;
/**
 * Filter where status contains the value (case-sensitive)
 */
'status.contains'?: string;
/**
 * Filter where status contains the value (case-insensitive)
 */
'status.icontains'?: string;
/**
 * Filter where status starts with the value (case-sensitive)
 */
'status.startsWith'?: string;
/**
 * Filter where status starts with the value (case-insensitive)
 */
'status.istartswith'?: string;
/**
 * Filter by authorId
 */
authorId?: string;
/**
 * Filter by categories
 */
categories?: string;
/**
 * Filter by createdAt (exact match, ISO date string for dates)
 */
createdAt?: string;
/**
 * Filter where createdAt is greater than
 */
'createdAt.gt'?: string;
/**
 * Filter where createdAt is greater than or equal
 */
'createdAt.gte'?: string;
/**
 * Filter where createdAt is less than
 */
'createdAt.lt'?: string;
/**
 * Filter where createdAt is less than or equal
 */
'createdAt.lte'?: string;
/**
 * Filter by updatedAt (exact match, ISO date string for dates)
 */
updatedAt?: string;
/**
 * Filter where updatedAt is greater than
 */
'updatedAt.gt'?: string;
/**
 * Filter where updatedAt is greater than or equal
 */
'updatedAt.gte'?: string;
/**
 * Filter where updatedAt is less than
 */
'updatedAt.lt'?: string;
/**
 * Filter where updatedAt is less than or equal
 */
'updatedAt.lte'?: string;
};

export type PostsQueryControllerFindSitemapSort = typeof PostsQueryControllerFindSitemapSort[keyof typeof PostsQueryControllerFindSitemapSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostsQueryControllerFindSitemapSort = {
  title: 'title',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  '-title': '-title',
  '-slug': '-slug',
  '-createdAt': '-createdAt',
  '-updatedAt': '-updatedAt',
} as const;

export type PostsQueryControllerFindSitemap200 = {
  items?: PostSitemapDto[];
  meta?: PageMetaDto;
};

export type PostsFileControllerUploadFileBody = {
  /** The file to upload */
  file: Blob;
  /** EXIF metadata as JSON string */
  exif?: string;
};

export type PostsAnalyticsControllerGetPostStatistics200ByTypeItem = {
  type?: string;
  count?: number;
};

export type PostsAnalyticsControllerGetPostStatistics200ByStatusItem = {
  status?: string;
  count?: number;
};

export type PostsAnalyticsControllerGetPostStatistics200 = {
  total?: number;
  published?: number;
  draft?: number;
  byType?: PostsAnalyticsControllerGetPostStatistics200ByTypeItem[];
  byStatus?: PostsAnalyticsControllerGetPostStatistics200ByStatusItem[];
};

export type GptPostControllerSearchPostsParams = {
/**
 * Search query for finding relevant posts
 */
q: string;
};

export type PostsControllerFindByDomainParams = {
/**
 * Number of items to return (1-100, default: 20)
 */
limit?: number;
/**
 * Cursor token for next page (forward pagination)
 */
after?: string;
/**
 * Cursor token for previous page (backward pagination)
 */
before?: string;
/**
 * Sort field with optional '-' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt
 */
sort?: PostsControllerFindByDomainSort;
/**
 * Filter by domain (exact match)
 */
domain?: string;
/**
 * Filter where domain contains the value (case-sensitive)
 */
'domain.contains'?: string;
/**
 * Filter where domain contains the value (case-insensitive)
 */
'domain.icontains'?: string;
/**
 * Filter where domain starts with the value (case-sensitive)
 */
'domain.startsWith'?: string;
/**
 * Filter where domain starts with the value (case-insensitive)
 */
'domain.istartswith'?: string;
/**
 * Filter by title (exact match)
 */
title?: string;
/**
 * Filter where title contains the value (case-sensitive)
 */
'title.contains'?: string;
/**
 * Filter where title contains the value (case-insensitive)
 */
'title.icontains'?: string;
/**
 * Filter where title starts with the value (case-sensitive)
 */
'title.startsWith'?: string;
/**
 * Filter where title starts with the value (case-insensitive)
 */
'title.istartswith'?: string;
/**
 * Filter by slug (exact match)
 */
slug?: string;
/**
 * Filter where slug contains the value (case-sensitive)
 */
'slug.contains'?: string;
/**
 * Filter where slug contains the value (case-insensitive)
 */
'slug.icontains'?: string;
/**
 * Filter where slug starts with the value (case-sensitive)
 */
'slug.startsWith'?: string;
/**
 * Filter where slug starts with the value (case-insensitive)
 */
'slug.istartswith'?: string;
/**
 * Filter by description (exact match)
 */
description?: string;
/**
 * Filter where description contains the value (case-sensitive)
 */
'description.contains'?: string;
/**
 * Filter where description contains the value (case-insensitive)
 */
'description.icontains'?: string;
/**
 * Filter where description starts with the value (case-sensitive)
 */
'description.startsWith'?: string;
/**
 * Filter where description starts with the value (case-insensitive)
 */
'description.istartswith'?: string;
/**
 * Filter by tags (exact match)
 */
tags?: string;
/**
 * Filter where tags contains the value (case-sensitive)
 */
'tags.contains'?: string;
/**
 * Filter where tags contains the value (case-insensitive)
 */
'tags.icontains'?: string;
/**
 * Filter where tags starts with the value (case-sensitive)
 */
'tags.startsWith'?: string;
/**
 * Filter where tags starts with the value (case-insensitive)
 */
'tags.istartswith'?: string;
/**
 * Filter by type (exact match)
 */
type?: string;
/**
 * Filter where type contains the value (case-sensitive)
 */
'type.contains'?: string;
/**
 * Filter where type contains the value (case-insensitive)
 */
'type.icontains'?: string;
/**
 * Filter where type starts with the value (case-sensitive)
 */
'type.startsWith'?: string;
/**
 * Filter where type starts with the value (case-insensitive)
 */
'type.istartswith'?: string;
/**
 * Filter by status (exact match)
 */
status?: string;
/**
 * Filter where status contains the value (case-sensitive)
 */
'status.contains'?: string;
/**
 * Filter where status contains the value (case-insensitive)
 */
'status.icontains'?: string;
/**
 * Filter where status starts with the value (case-sensitive)
 */
'status.startsWith'?: string;
/**
 * Filter where status starts with the value (case-insensitive)
 */
'status.istartswith'?: string;
/**
 * Filter by authorId
 */
authorId?: string;
/**
 * Filter by categories
 */
categories?: string;
/**
 * Filter by createdAt (exact match, ISO date string for dates)
 */
createdAt?: string;
/**
 * Filter where createdAt is greater than
 */
'createdAt.gt'?: string;
/**
 * Filter where createdAt is greater than or equal
 */
'createdAt.gte'?: string;
/**
 * Filter where createdAt is less than
 */
'createdAt.lt'?: string;
/**
 * Filter where createdAt is less than or equal
 */
'createdAt.lte'?: string;
/**
 * Filter by updatedAt (exact match, ISO date string for dates)
 */
updatedAt?: string;
/**
 * Filter where updatedAt is greater than
 */
'updatedAt.gt'?: string;
/**
 * Filter where updatedAt is greater than or equal
 */
'updatedAt.gte'?: string;
/**
 * Filter where updatedAt is less than
 */
'updatedAt.lt'?: string;
/**
 * Filter where updatedAt is less than or equal
 */
'updatedAt.lte'?: string;
};

export type PostsControllerFindByDomainSort = typeof PostsControllerFindByDomainSort[keyof typeof PostsControllerFindByDomainSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostsControllerFindByDomainSort = {
  title: 'title',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  '-title': '-title',
  '-slug': '-slug',
  '-createdAt': '-createdAt',
  '-updatedAt': '-updatedAt',
} as const;

export type PostsControllerFindByDomain200 = {
  items?: PostDto[];
  meta?: PageMetaDto;
};

export type PostsControllerFindByStatusParams = {
/**
 * Number of items to return (1-100, default: 20)
 */
limit?: number;
/**
 * Cursor token for next page (forward pagination)
 */
after?: string;
/**
 * Cursor token for previous page (backward pagination)
 */
before?: string;
/**
 * Sort field with optional '-' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt
 */
sort?: PostsControllerFindByStatusSort;
/**
 * Filter by domain (exact match)
 */
domain?: string;
/**
 * Filter where domain contains the value (case-sensitive)
 */
'domain.contains'?: string;
/**
 * Filter where domain contains the value (case-insensitive)
 */
'domain.icontains'?: string;
/**
 * Filter where domain starts with the value (case-sensitive)
 */
'domain.startsWith'?: string;
/**
 * Filter where domain starts with the value (case-insensitive)
 */
'domain.istartswith'?: string;
/**
 * Filter by title (exact match)
 */
title?: string;
/**
 * Filter where title contains the value (case-sensitive)
 */
'title.contains'?: string;
/**
 * Filter where title contains the value (case-insensitive)
 */
'title.icontains'?: string;
/**
 * Filter where title starts with the value (case-sensitive)
 */
'title.startsWith'?: string;
/**
 * Filter where title starts with the value (case-insensitive)
 */
'title.istartswith'?: string;
/**
 * Filter by slug (exact match)
 */
slug?: string;
/**
 * Filter where slug contains the value (case-sensitive)
 */
'slug.contains'?: string;
/**
 * Filter where slug contains the value (case-insensitive)
 */
'slug.icontains'?: string;
/**
 * Filter where slug starts with the value (case-sensitive)
 */
'slug.startsWith'?: string;
/**
 * Filter where slug starts with the value (case-insensitive)
 */
'slug.istartswith'?: string;
/**
 * Filter by description (exact match)
 */
description?: string;
/**
 * Filter where description contains the value (case-sensitive)
 */
'description.contains'?: string;
/**
 * Filter where description contains the value (case-insensitive)
 */
'description.icontains'?: string;
/**
 * Filter where description starts with the value (case-sensitive)
 */
'description.startsWith'?: string;
/**
 * Filter where description starts with the value (case-insensitive)
 */
'description.istartswith'?: string;
/**
 * Filter by tags (exact match)
 */
tags?: string;
/**
 * Filter where tags contains the value (case-sensitive)
 */
'tags.contains'?: string;
/**
 * Filter where tags contains the value (case-insensitive)
 */
'tags.icontains'?: string;
/**
 * Filter where tags starts with the value (case-sensitive)
 */
'tags.startsWith'?: string;
/**
 * Filter where tags starts with the value (case-insensitive)
 */
'tags.istartswith'?: string;
/**
 * Filter by type (exact match)
 */
type?: string;
/**
 * Filter where type contains the value (case-sensitive)
 */
'type.contains'?: string;
/**
 * Filter where type contains the value (case-insensitive)
 */
'type.icontains'?: string;
/**
 * Filter where type starts with the value (case-sensitive)
 */
'type.startsWith'?: string;
/**
 * Filter where type starts with the value (case-insensitive)
 */
'type.istartswith'?: string;
/**
 * Filter by status (exact match)
 */
status?: string;
/**
 * Filter where status contains the value (case-sensitive)
 */
'status.contains'?: string;
/**
 * Filter where status contains the value (case-insensitive)
 */
'status.icontains'?: string;
/**
 * Filter where status starts with the value (case-sensitive)
 */
'status.startsWith'?: string;
/**
 * Filter where status starts with the value (case-insensitive)
 */
'status.istartswith'?: string;
/**
 * Filter by authorId
 */
authorId?: string;
/**
 * Filter by categories
 */
categories?: string;
/**
 * Filter by createdAt (exact match, ISO date string for dates)
 */
createdAt?: string;
/**
 * Filter where createdAt is greater than
 */
'createdAt.gt'?: string;
/**
 * Filter where createdAt is greater than or equal
 */
'createdAt.gte'?: string;
/**
 * Filter where createdAt is less than
 */
'createdAt.lt'?: string;
/**
 * Filter where createdAt is less than or equal
 */
'createdAt.lte'?: string;
/**
 * Filter by updatedAt (exact match, ISO date string for dates)
 */
updatedAt?: string;
/**
 * Filter where updatedAt is greater than
 */
'updatedAt.gt'?: string;
/**
 * Filter where updatedAt is greater than or equal
 */
'updatedAt.gte'?: string;
/**
 * Filter where updatedAt is less than
 */
'updatedAt.lt'?: string;
/**
 * Filter where updatedAt is less than or equal
 */
'updatedAt.lte'?: string;
};

export type PostsControllerFindByStatusSort = typeof PostsControllerFindByStatusSort[keyof typeof PostsControllerFindByStatusSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostsControllerFindByStatusSort = {
  title: 'title',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  '-title': '-title',
  '-slug': '-slug',
  '-createdAt': '-createdAt',
  '-updatedAt': '-updatedAt',
} as const;

export type PostsControllerFindByStatus200 = {
  items?: PostDto[];
  meta?: PageMetaDto;
};

export type PostsControllerFindByTagsParams = {
/**
 * Number of items to return (1-100, default: 20)
 */
limit?: number;
/**
 * Cursor token for next page (forward pagination)
 */
after?: string;
/**
 * Cursor token for previous page (backward pagination)
 */
before?: string;
/**
 * Sort field with optional '-' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt
 */
sort?: PostsControllerFindByTagsSort;
/**
 * Filter by domain (exact match)
 */
domain?: string;
/**
 * Filter where domain contains the value (case-sensitive)
 */
'domain.contains'?: string;
/**
 * Filter where domain contains the value (case-insensitive)
 */
'domain.icontains'?: string;
/**
 * Filter where domain starts with the value (case-sensitive)
 */
'domain.startsWith'?: string;
/**
 * Filter where domain starts with the value (case-insensitive)
 */
'domain.istartswith'?: string;
/**
 * Filter by title (exact match)
 */
title?: string;
/**
 * Filter where title contains the value (case-sensitive)
 */
'title.contains'?: string;
/**
 * Filter where title contains the value (case-insensitive)
 */
'title.icontains'?: string;
/**
 * Filter where title starts with the value (case-sensitive)
 */
'title.startsWith'?: string;
/**
 * Filter where title starts with the value (case-insensitive)
 */
'title.istartswith'?: string;
/**
 * Filter by slug (exact match)
 */
slug?: string;
/**
 * Filter where slug contains the value (case-sensitive)
 */
'slug.contains'?: string;
/**
 * Filter where slug contains the value (case-insensitive)
 */
'slug.icontains'?: string;
/**
 * Filter where slug starts with the value (case-sensitive)
 */
'slug.startsWith'?: string;
/**
 * Filter where slug starts with the value (case-insensitive)
 */
'slug.istartswith'?: string;
/**
 * Filter by description (exact match)
 */
description?: string;
/**
 * Filter where description contains the value (case-sensitive)
 */
'description.contains'?: string;
/**
 * Filter where description contains the value (case-insensitive)
 */
'description.icontains'?: string;
/**
 * Filter where description starts with the value (case-sensitive)
 */
'description.startsWith'?: string;
/**
 * Filter where description starts with the value (case-insensitive)
 */
'description.istartswith'?: string;
/**
 * Filter by tags (exact match)
 */
tags?: string;
/**
 * Filter where tags contains the value (case-sensitive)
 */
'tags.contains'?: string;
/**
 * Filter where tags contains the value (case-insensitive)
 */
'tags.icontains'?: string;
/**
 * Filter where tags starts with the value (case-sensitive)
 */
'tags.startsWith'?: string;
/**
 * Filter where tags starts with the value (case-insensitive)
 */
'tags.istartswith'?: string;
/**
 * Filter by type (exact match)
 */
type?: string;
/**
 * Filter where type contains the value (case-sensitive)
 */
'type.contains'?: string;
/**
 * Filter where type contains the value (case-insensitive)
 */
'type.icontains'?: string;
/**
 * Filter where type starts with the value (case-sensitive)
 */
'type.startsWith'?: string;
/**
 * Filter where type starts with the value (case-insensitive)
 */
'type.istartswith'?: string;
/**
 * Filter by status (exact match)
 */
status?: string;
/**
 * Filter where status contains the value (case-sensitive)
 */
'status.contains'?: string;
/**
 * Filter where status contains the value (case-insensitive)
 */
'status.icontains'?: string;
/**
 * Filter where status starts with the value (case-sensitive)
 */
'status.startsWith'?: string;
/**
 * Filter where status starts with the value (case-insensitive)
 */
'status.istartswith'?: string;
/**
 * Filter by authorId
 */
authorId?: string;
/**
 * Filter by categories
 */
categories?: string;
/**
 * Filter by createdAt (exact match, ISO date string for dates)
 */
createdAt?: string;
/**
 * Filter where createdAt is greater than
 */
'createdAt.gt'?: string;
/**
 * Filter where createdAt is greater than or equal
 */
'createdAt.gte'?: string;
/**
 * Filter where createdAt is less than
 */
'createdAt.lt'?: string;
/**
 * Filter where createdAt is less than or equal
 */
'createdAt.lte'?: string;
/**
 * Filter by updatedAt (exact match, ISO date string for dates)
 */
updatedAt?: string;
/**
 * Filter where updatedAt is greater than
 */
'updatedAt.gt'?: string;
/**
 * Filter where updatedAt is greater than or equal
 */
'updatedAt.gte'?: string;
/**
 * Filter where updatedAt is less than
 */
'updatedAt.lt'?: string;
/**
 * Filter where updatedAt is less than or equal
 */
'updatedAt.lte'?: string;
};

export type PostsControllerFindByTagsSort = typeof PostsControllerFindByTagsSort[keyof typeof PostsControllerFindByTagsSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostsControllerFindByTagsSort = {
  title: 'title',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  '-title': '-title',
  '-slug': '-slug',
  '-createdAt': '-createdAt',
  '-updatedAt': '-updatedAt',
} as const;

export type PostsControllerFindByTags200 = {
  items?: PostDto[];
  meta?: PageMetaDto;
};

export type PostsControllerFindByAuthorParams = {
/**
 * Number of items to return (1-100, default: 20)
 */
limit?: number;
/**
 * Cursor token for next page (forward pagination)
 */
after?: string;
/**
 * Cursor token for previous page (backward pagination)
 */
before?: string;
/**
 * Sort field with optional '-' prefix for descending. Allowed fields: title, slug, createdAt, updatedAt
 */
sort?: PostsControllerFindByAuthorSort;
/**
 * Filter by domain (exact match)
 */
domain?: string;
/**
 * Filter where domain contains the value (case-sensitive)
 */
'domain.contains'?: string;
/**
 * Filter where domain contains the value (case-insensitive)
 */
'domain.icontains'?: string;
/**
 * Filter where domain starts with the value (case-sensitive)
 */
'domain.startsWith'?: string;
/**
 * Filter where domain starts with the value (case-insensitive)
 */
'domain.istartswith'?: string;
/**
 * Filter by title (exact match)
 */
title?: string;
/**
 * Filter where title contains the value (case-sensitive)
 */
'title.contains'?: string;
/**
 * Filter where title contains the value (case-insensitive)
 */
'title.icontains'?: string;
/**
 * Filter where title starts with the value (case-sensitive)
 */
'title.startsWith'?: string;
/**
 * Filter where title starts with the value (case-insensitive)
 */
'title.istartswith'?: string;
/**
 * Filter by slug (exact match)
 */
slug?: string;
/**
 * Filter where slug contains the value (case-sensitive)
 */
'slug.contains'?: string;
/**
 * Filter where slug contains the value (case-insensitive)
 */
'slug.icontains'?: string;
/**
 * Filter where slug starts with the value (case-sensitive)
 */
'slug.startsWith'?: string;
/**
 * Filter where slug starts with the value (case-insensitive)
 */
'slug.istartswith'?: string;
/**
 * Filter by description (exact match)
 */
description?: string;
/**
 * Filter where description contains the value (case-sensitive)
 */
'description.contains'?: string;
/**
 * Filter where description contains the value (case-insensitive)
 */
'description.icontains'?: string;
/**
 * Filter where description starts with the value (case-sensitive)
 */
'description.startsWith'?: string;
/**
 * Filter where description starts with the value (case-insensitive)
 */
'description.istartswith'?: string;
/**
 * Filter by tags (exact match)
 */
tags?: string;
/**
 * Filter where tags contains the value (case-sensitive)
 */
'tags.contains'?: string;
/**
 * Filter where tags contains the value (case-insensitive)
 */
'tags.icontains'?: string;
/**
 * Filter where tags starts with the value (case-sensitive)
 */
'tags.startsWith'?: string;
/**
 * Filter where tags starts with the value (case-insensitive)
 */
'tags.istartswith'?: string;
/**
 * Filter by type (exact match)
 */
type?: string;
/**
 * Filter where type contains the value (case-sensitive)
 */
'type.contains'?: string;
/**
 * Filter where type contains the value (case-insensitive)
 */
'type.icontains'?: string;
/**
 * Filter where type starts with the value (case-sensitive)
 */
'type.startsWith'?: string;
/**
 * Filter where type starts with the value (case-insensitive)
 */
'type.istartswith'?: string;
/**
 * Filter by status (exact match)
 */
status?: string;
/**
 * Filter where status contains the value (case-sensitive)
 */
'status.contains'?: string;
/**
 * Filter where status contains the value (case-insensitive)
 */
'status.icontains'?: string;
/**
 * Filter where status starts with the value (case-sensitive)
 */
'status.startsWith'?: string;
/**
 * Filter where status starts with the value (case-insensitive)
 */
'status.istartswith'?: string;
/**
 * Filter by authorId
 */
authorId?: string;
/**
 * Filter by categories
 */
categories?: string;
/**
 * Filter by createdAt (exact match, ISO date string for dates)
 */
createdAt?: string;
/**
 * Filter where createdAt is greater than
 */
'createdAt.gt'?: string;
/**
 * Filter where createdAt is greater than or equal
 */
'createdAt.gte'?: string;
/**
 * Filter where createdAt is less than
 */
'createdAt.lt'?: string;
/**
 * Filter where createdAt is less than or equal
 */
'createdAt.lte'?: string;
/**
 * Filter by updatedAt (exact match, ISO date string for dates)
 */
updatedAt?: string;
/**
 * Filter where updatedAt is greater than
 */
'updatedAt.gt'?: string;
/**
 * Filter where updatedAt is greater than or equal
 */
'updatedAt.gte'?: string;
/**
 * Filter where updatedAt is less than
 */
'updatedAt.lt'?: string;
/**
 * Filter where updatedAt is less than or equal
 */
'updatedAt.lte'?: string;
};

export type PostsControllerFindByAuthorSort = typeof PostsControllerFindByAuthorSort[keyof typeof PostsControllerFindByAuthorSort];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostsControllerFindByAuthorSort = {
  title: 'title',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  '-title': '-title',
  '-slug': '-slug',
  '-createdAt': '-createdAt',
  '-updatedAt': '-updatedAt',
} as const;

export type PostsControllerFindByAuthor200 = {
  items?: PostDto[];
  meta?: PageMetaDto;
};

export type FileControllerUploadBody = {
  /** The file to upload */
  file?: Blob;
};

