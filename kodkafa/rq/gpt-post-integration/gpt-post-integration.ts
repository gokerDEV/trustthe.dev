/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * KODKAFA API
 * Stack: Nest.js + MongoDB + Mongoose + Redis - OAuth 2.1 Compliant
 * OpenAPI spec version: 0.0.3
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreatePostDto,
  ErrorResponseDto,
  GptPostControllerSearchPostsParams,
  OpenAIFileUploadDto,
  PostDto,
  ResponseIdDto,
  ResponseStatusDto,
  UpdatePostDto,
  UpdatePostFileDto
} from '../kodkafaApi.schemas';

import { clientMutator } from '../../../lib/api/client.mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create a GPT-generated post
 */
export type gptPostControllerCreateGptPostResponse201 = {
  data: ResponseIdDto
  status: 201
}

export type gptPostControllerCreateGptPostResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type gptPostControllerCreateGptPostResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type gptPostControllerCreateGptPostResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type gptPostControllerCreateGptPostResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type gptPostControllerCreateGptPostResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type gptPostControllerCreateGptPostResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type gptPostControllerCreateGptPostResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type gptPostControllerCreateGptPostResponseSuccess = (gptPostControllerCreateGptPostResponse201) & {
  headers: Headers;
};
export type gptPostControllerCreateGptPostResponseError = (gptPostControllerCreateGptPostResponse400 | gptPostControllerCreateGptPostResponse401 | gptPostControllerCreateGptPostResponse403 | gptPostControllerCreateGptPostResponse404 | gptPostControllerCreateGptPostResponse409 | gptPostControllerCreateGptPostResponse422 | gptPostControllerCreateGptPostResponse500) & {
  headers: Headers;
};

export type gptPostControllerCreateGptPostResponse = (gptPostControllerCreateGptPostResponseSuccess | gptPostControllerCreateGptPostResponseError)

export const getGptPostControllerCreateGptPostUrl = () => {


  

  return `/api/gpt/posts`
}

export const gptPostControllerCreateGptPost = async (createPostDto: CreatePostDto, options?: RequestInit): Promise<gptPostControllerCreateGptPostResponse> => {
  
  return clientMutator<gptPostControllerCreateGptPostResponse>(getGptPostControllerCreateGptPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createPostDto,)
  }
);}




export const getGptPostControllerCreateGptPostMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerCreateGptPost>>, TError,{data: CreatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerCreateGptPost>>, TError,{data: CreatePostDto}, TContext> => {

const mutationKey = ['gptPostControllerCreateGptPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gptPostControllerCreateGptPost>>, {data: CreatePostDto}> = (props) => {
          const {data} = props ?? {};

          return  gptPostControllerCreateGptPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GptPostControllerCreateGptPostMutationResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerCreateGptPost>>>
    export type GptPostControllerCreateGptPostMutationBody = CreatePostDto
    export type GptPostControllerCreateGptPostMutationError = ErrorResponseDto

    /**
 * @summary Create a GPT-generated post
 */
export const useGptPostControllerCreateGptPost = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerCreateGptPost>>, TError,{data: CreatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof gptPostControllerCreateGptPost>>,
        TError,
        {data: CreatePostDto},
        TContext
      > => {

      const mutationOptions = getGptPostControllerCreateGptPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Search posts for GPT context
 */
export type gptPostControllerSearchPostsResponse200 = {
  data: PostDto[]
  status: 200
}

export type gptPostControllerSearchPostsResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type gptPostControllerSearchPostsResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type gptPostControllerSearchPostsResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type gptPostControllerSearchPostsResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type gptPostControllerSearchPostsResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type gptPostControllerSearchPostsResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type gptPostControllerSearchPostsResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type gptPostControllerSearchPostsResponseSuccess = (gptPostControllerSearchPostsResponse200) & {
  headers: Headers;
};
export type gptPostControllerSearchPostsResponseError = (gptPostControllerSearchPostsResponse400 | gptPostControllerSearchPostsResponse401 | gptPostControllerSearchPostsResponse403 | gptPostControllerSearchPostsResponse404 | gptPostControllerSearchPostsResponse409 | gptPostControllerSearchPostsResponse422 | gptPostControllerSearchPostsResponse500) & {
  headers: Headers;
};

export type gptPostControllerSearchPostsResponse = (gptPostControllerSearchPostsResponseSuccess | gptPostControllerSearchPostsResponseError)

export const getGptPostControllerSearchPostsUrl = (params: GptPostControllerSearchPostsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/gpt/posts/search?${stringifiedParams}` : `/api/gpt/posts/search`
}

export const gptPostControllerSearchPosts = async (params: GptPostControllerSearchPostsParams, options?: RequestInit): Promise<gptPostControllerSearchPostsResponse> => {
  
  return clientMutator<gptPostControllerSearchPostsResponse>(getGptPostControllerSearchPostsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGptPostControllerSearchPostsInfiniteQueryKey = (params?: GptPostControllerSearchPostsParams,) => {
    return [
    'infinite', `/api/gpt/posts/search`, ...(params ? [params]: [])
    ] as const;
    }

export const getGptPostControllerSearchPostsQueryKey = (params?: GptPostControllerSearchPostsParams,) => {
    return [
    `/api/gpt/posts/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGptPostControllerSearchPostsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>, TError = ErrorResponseDto>(params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGptPostControllerSearchPostsInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>> = ({ signal }) => gptPostControllerSearchPosts(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GptPostControllerSearchPostsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>
export type GptPostControllerSearchPostsInfiniteQueryError = ErrorResponseDto


export function useGptPostControllerSearchPostsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerSearchPostsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerSearchPostsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search posts for GPT context
 */

export function useGptPostControllerSearchPostsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGptPostControllerSearchPostsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGptPostControllerSearchPostsQueryOptions = <TData = Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError = ErrorResponseDto>(params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGptPostControllerSearchPostsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>> = ({ signal }) => gptPostControllerSearchPosts(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GptPostControllerSearchPostsQueryResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>>
export type GptPostControllerSearchPostsQueryError = ErrorResponseDto


export function useGptPostControllerSearchPosts<TData = Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerSearchPosts<TData = Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerSearchPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerSearchPosts<TData = Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search posts for GPT context
 */

export function useGptPostControllerSearchPosts<TData = Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError = ErrorResponseDto>(
 params: GptPostControllerSearchPostsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerSearchPosts>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGptPostControllerSearchPostsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get post by ID for GPT processing
 */
export type gptPostControllerFindPostByIdResponse200 = {
  data: PostDto
  status: 200
}

export type gptPostControllerFindPostByIdResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type gptPostControllerFindPostByIdResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type gptPostControllerFindPostByIdResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type gptPostControllerFindPostByIdResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type gptPostControllerFindPostByIdResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type gptPostControllerFindPostByIdResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type gptPostControllerFindPostByIdResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type gptPostControllerFindPostByIdResponseSuccess = (gptPostControllerFindPostByIdResponse200) & {
  headers: Headers;
};
export type gptPostControllerFindPostByIdResponseError = (gptPostControllerFindPostByIdResponse400 | gptPostControllerFindPostByIdResponse401 | gptPostControllerFindPostByIdResponse403 | gptPostControllerFindPostByIdResponse404 | gptPostControllerFindPostByIdResponse409 | gptPostControllerFindPostByIdResponse422 | gptPostControllerFindPostByIdResponse500) & {
  headers: Headers;
};

export type gptPostControllerFindPostByIdResponse = (gptPostControllerFindPostByIdResponseSuccess | gptPostControllerFindPostByIdResponseError)

export const getGptPostControllerFindPostByIdUrl = (id: string,) => {


  

  return `/api/gpt/posts/${id}`
}

export const gptPostControllerFindPostById = async (id: string, options?: RequestInit): Promise<gptPostControllerFindPostByIdResponse> => {
  
  return clientMutator<gptPostControllerFindPostByIdResponse>(getGptPostControllerFindPostByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGptPostControllerFindPostByIdInfiniteQueryKey = (id?: string,) => {
    return [
    'infinite', `/api/gpt/posts/${id}`
    ] as const;
    }

export const getGptPostControllerFindPostByIdQueryKey = (id?: string,) => {
    return [
    `/api/gpt/posts/${id}`
    ] as const;
    }

    
export const getGptPostControllerFindPostByIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>, TError = ErrorResponseDto>(id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGptPostControllerFindPostByIdInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gptPostControllerFindPostById>>> = ({ signal }) => gptPostControllerFindPostById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GptPostControllerFindPostByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>
export type GptPostControllerFindPostByIdInfiniteQueryError = ErrorResponseDto


export function useGptPostControllerFindPostByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>, TError = ErrorResponseDto>(
 id: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerFindPostByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerFindPostByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get post by ID for GPT processing
 */

export function useGptPostControllerFindPostByIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGptPostControllerFindPostByIdInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGptPostControllerFindPostByIdQueryOptions = <TData = Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError = ErrorResponseDto>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGptPostControllerFindPostByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gptPostControllerFindPostById>>> = ({ signal }) => gptPostControllerFindPostById(id, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id),  staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GptPostControllerFindPostByIdQueryResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerFindPostById>>>
export type GptPostControllerFindPostByIdQueryError = ErrorResponseDto


export function useGptPostControllerFindPostById<TData = Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError = ErrorResponseDto>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerFindPostById<TData = Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>,
          TError,
          Awaited<ReturnType<typeof gptPostControllerFindPostById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGptPostControllerFindPostById<TData = Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get post by ID for GPT processing
 */

export function useGptPostControllerFindPostById<TData = Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError = ErrorResponseDto>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gptPostControllerFindPostById>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGptPostControllerFindPostByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update post with GPT-generated content
 */
export type gptPostControllerUpdateGptPostResponse200 = {
  data: ResponseIdDto
  status: 200
}

export type gptPostControllerUpdateGptPostResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type gptPostControllerUpdateGptPostResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type gptPostControllerUpdateGptPostResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type gptPostControllerUpdateGptPostResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type gptPostControllerUpdateGptPostResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type gptPostControllerUpdateGptPostResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type gptPostControllerUpdateGptPostResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type gptPostControllerUpdateGptPostResponseSuccess = (gptPostControllerUpdateGptPostResponse200) & {
  headers: Headers;
};
export type gptPostControllerUpdateGptPostResponseError = (gptPostControllerUpdateGptPostResponse400 | gptPostControllerUpdateGptPostResponse401 | gptPostControllerUpdateGptPostResponse403 | gptPostControllerUpdateGptPostResponse404 | gptPostControllerUpdateGptPostResponse409 | gptPostControllerUpdateGptPostResponse422 | gptPostControllerUpdateGptPostResponse500) & {
  headers: Headers;
};

export type gptPostControllerUpdateGptPostResponse = (gptPostControllerUpdateGptPostResponseSuccess | gptPostControllerUpdateGptPostResponseError)

export const getGptPostControllerUpdateGptPostUrl = (id: string,) => {


  

  return `/api/gpt/posts/${id}`
}

export const gptPostControllerUpdateGptPost = async (id: string,
    updatePostDto: UpdatePostDto, options?: RequestInit): Promise<gptPostControllerUpdateGptPostResponse> => {
  
  return clientMutator<gptPostControllerUpdateGptPostResponse>(getGptPostControllerUpdateGptPostUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePostDto,)
  }
);}




export const getGptPostControllerUpdateGptPostMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUpdateGptPost>>, TError,{id: string;data: UpdatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUpdateGptPost>>, TError,{id: string;data: UpdatePostDto}, TContext> => {

const mutationKey = ['gptPostControllerUpdateGptPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gptPostControllerUpdateGptPost>>, {id: string;data: UpdatePostDto}> = (props) => {
          const {id,data} = props ?? {};

          return  gptPostControllerUpdateGptPost(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GptPostControllerUpdateGptPostMutationResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerUpdateGptPost>>>
    export type GptPostControllerUpdateGptPostMutationBody = UpdatePostDto
    export type GptPostControllerUpdateGptPostMutationError = ErrorResponseDto

    /**
 * @summary Update post with GPT-generated content
 */
export const useGptPostControllerUpdateGptPost = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUpdateGptPost>>, TError,{id: string;data: UpdatePostDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof gptPostControllerUpdateGptPost>>,
        TError,
        {id: string;data: UpdatePostDto},
        TContext
      > => {

      const mutationOptions = getGptPostControllerUpdateGptPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Process and attach files from OpenAI Assistant API responses
 * @summary Upload files from OpenAI file references
 */
export type gptPostControllerUploadOpenAIFilesResponse200 = {
  data: ResponseStatusDto
  status: 200
}

export type gptPostControllerUploadOpenAIFilesResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type gptPostControllerUploadOpenAIFilesResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type gptPostControllerUploadOpenAIFilesResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type gptPostControllerUploadOpenAIFilesResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type gptPostControllerUploadOpenAIFilesResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type gptPostControllerUploadOpenAIFilesResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type gptPostControllerUploadOpenAIFilesResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type gptPostControllerUploadOpenAIFilesResponseSuccess = (gptPostControllerUploadOpenAIFilesResponse200) & {
  headers: Headers;
};
export type gptPostControllerUploadOpenAIFilesResponseError = (gptPostControllerUploadOpenAIFilesResponse400 | gptPostControllerUploadOpenAIFilesResponse401 | gptPostControllerUploadOpenAIFilesResponse403 | gptPostControllerUploadOpenAIFilesResponse404 | gptPostControllerUploadOpenAIFilesResponse409 | gptPostControllerUploadOpenAIFilesResponse422 | gptPostControllerUploadOpenAIFilesResponse500) & {
  headers: Headers;
};

export type gptPostControllerUploadOpenAIFilesResponse = (gptPostControllerUploadOpenAIFilesResponseSuccess | gptPostControllerUploadOpenAIFilesResponseError)

export const getGptPostControllerUploadOpenAIFilesUrl = (id: string,) => {


  

  return `/api/gpt/posts/${id}/openai-files`
}

export const gptPostControllerUploadOpenAIFiles = async (id: string,
    openAIFileUploadDto: OpenAIFileUploadDto, options?: RequestInit): Promise<gptPostControllerUploadOpenAIFilesResponse> => {
  
  return clientMutator<gptPostControllerUploadOpenAIFilesResponse>(getGptPostControllerUploadOpenAIFilesUrl(id),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      openAIFileUploadDto,)
  }
);}




export const getGptPostControllerUploadOpenAIFilesMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUploadOpenAIFiles>>, TError,{id: string;data: OpenAIFileUploadDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUploadOpenAIFiles>>, TError,{id: string;data: OpenAIFileUploadDto}, TContext> => {

const mutationKey = ['gptPostControllerUploadOpenAIFiles'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gptPostControllerUploadOpenAIFiles>>, {id: string;data: OpenAIFileUploadDto}> = (props) => {
          const {id,data} = props ?? {};

          return  gptPostControllerUploadOpenAIFiles(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GptPostControllerUploadOpenAIFilesMutationResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerUploadOpenAIFiles>>>
    export type GptPostControllerUploadOpenAIFilesMutationBody = OpenAIFileUploadDto
    export type GptPostControllerUploadOpenAIFilesMutationError = ErrorResponseDto

    /**
 * @summary Upload files from OpenAI file references
 */
export const useGptPostControllerUploadOpenAIFiles = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUploadOpenAIFiles>>, TError,{id: string;data: OpenAIFileUploadDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof gptPostControllerUploadOpenAIFiles>>,
        TError,
        {id: string;data: OpenAIFileUploadDto},
        TContext
      > => {

      const mutationOptions = getGptPostControllerUploadOpenAIFilesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Update file metadata for GPT-uploaded files
 */
export type gptPostControllerUpdatePostFileResponse200 = {
  data: ResponseIdDto
  status: 200
}

export type gptPostControllerUpdatePostFileResponse400 = {
  data: ErrorResponseDto
  status: 400
}

export type gptPostControllerUpdatePostFileResponse401 = {
  data: ErrorResponseDto
  status: 401
}

export type gptPostControllerUpdatePostFileResponse403 = {
  data: ErrorResponseDto
  status: 403
}

export type gptPostControllerUpdatePostFileResponse404 = {
  data: ErrorResponseDto
  status: 404
}

export type gptPostControllerUpdatePostFileResponse409 = {
  data: ErrorResponseDto
  status: 409
}

export type gptPostControllerUpdatePostFileResponse422 = {
  data: ErrorResponseDto
  status: 422
}

export type gptPostControllerUpdatePostFileResponse500 = {
  data: ErrorResponseDto
  status: 500
}
    
export type gptPostControllerUpdatePostFileResponseSuccess = (gptPostControllerUpdatePostFileResponse200) & {
  headers: Headers;
};
export type gptPostControllerUpdatePostFileResponseError = (gptPostControllerUpdatePostFileResponse400 | gptPostControllerUpdatePostFileResponse401 | gptPostControllerUpdatePostFileResponse403 | gptPostControllerUpdatePostFileResponse404 | gptPostControllerUpdatePostFileResponse409 | gptPostControllerUpdatePostFileResponse422 | gptPostControllerUpdatePostFileResponse500) & {
  headers: Headers;
};

export type gptPostControllerUpdatePostFileResponse = (gptPostControllerUpdatePostFileResponseSuccess | gptPostControllerUpdatePostFileResponseError)

export const getGptPostControllerUpdatePostFileUrl = (id: string,
    fileId: string,) => {


  

  return `/api/gpt/posts/${id}/files/${fileId}`
}

export const gptPostControllerUpdatePostFile = async (id: string,
    fileId: string,
    updatePostFileDto: UpdatePostFileDto, options?: RequestInit): Promise<gptPostControllerUpdatePostFileResponse> => {
  
  return clientMutator<gptPostControllerUpdatePostFileResponse>(getGptPostControllerUpdatePostFileUrl(id,fileId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePostFileDto,)
  }
);}




export const getGptPostControllerUpdatePostFileMutationOptions = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUpdatePostFile>>, TError,{id: string;fileId: string;data: UpdatePostFileDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUpdatePostFile>>, TError,{id: string;fileId: string;data: UpdatePostFileDto}, TContext> => {

const mutationKey = ['gptPostControllerUpdatePostFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof gptPostControllerUpdatePostFile>>, {id: string;fileId: string;data: UpdatePostFileDto}> = (props) => {
          const {id,fileId,data} = props ?? {};

          return  gptPostControllerUpdatePostFile(id,fileId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GptPostControllerUpdatePostFileMutationResult = NonNullable<Awaited<ReturnType<typeof gptPostControllerUpdatePostFile>>>
    export type GptPostControllerUpdatePostFileMutationBody = UpdatePostFileDto
    export type GptPostControllerUpdatePostFileMutationError = ErrorResponseDto

    /**
 * @summary Update file metadata for GPT-uploaded files
 */
export const useGptPostControllerUpdatePostFile = <TError = ErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof gptPostControllerUpdatePostFile>>, TError,{id: string;fileId: string;data: UpdatePostFileDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof gptPostControllerUpdatePostFile>>,
        TError,
        {id: string;fileId: string;data: UpdatePostFileDto},
        TContext
      > => {

      const mutationOptions = getGptPostControllerUpdatePostFileMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    