/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * KODKAFA API
 * Stack: Nest.js + MongoDB + Mongoose + Redis - OAuth 2.1 Compliant
 * OpenAPI spec version: 0.0.3
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AttestRequestDto,
  AttestResponseDto,
  AuthorizeControllerAuthorizeParams,
  OAuthErrorResponseDto,
  OAuthIntrospectRequestDto,
  OAuthIntrospectResponseDto,
  OAuthRevokeRequestDto,
  OAuthTokenRequestDto,
  OAuthTokenResponseDto,
  PARRequestDto,
  PARResponseDto
} from '../kodkafaApi.schemas';

import { clientMutator } from '../../../lib/api/client.mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Universal token endpoint supporting client_credentials, authorization_code, and refresh_token grant types. RFC 6749 compliant with form-encoded requests and JSON responses. Requires client authentication (Basic or POST). PKCE validation for authorization_code grant.
 * @summary OAuth 2.1 Token Endpoint
 */
export type oAuthControllerTokenResponse200 = {
  data: OAuthTokenResponseDto
  status: 200
}

export type oAuthControllerTokenResponse400 = {
  data: OAuthErrorResponseDto
  status: 400
}

export type oAuthControllerTokenResponse401 = {
  data: OAuthErrorResponseDto
  status: 401
}
    
export type oAuthControllerTokenResponseSuccess = (oAuthControllerTokenResponse200) & {
  headers: Headers;
};
export type oAuthControllerTokenResponseError = (oAuthControllerTokenResponse400 | oAuthControllerTokenResponse401) & {
  headers: Headers;
};

export type oAuthControllerTokenResponse = (oAuthControllerTokenResponseSuccess | oAuthControllerTokenResponseError)

export const getOAuthControllerTokenUrl = () => {


  

  return `/api/oauth/token`
}

export const oAuthControllerToken = async (oAuthTokenRequestDto: OAuthTokenRequestDto, options?: RequestInit): Promise<oAuthControllerTokenResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`grant_type`, oAuthTokenRequestDto.grant_type)
if(oAuthTokenRequestDto.client_id !== undefined) {
 formUrlEncoded.append(`client_id`, oAuthTokenRequestDto.client_id)
 }
if(oAuthTokenRequestDto.client_secret !== undefined) {
 formUrlEncoded.append(`client_secret`, oAuthTokenRequestDto.client_secret)
 }
if(oAuthTokenRequestDto.code !== undefined) {
 formUrlEncoded.append(`code`, oAuthTokenRequestDto.code)
 }
if(oAuthTokenRequestDto.code_verifier !== undefined) {
 formUrlEncoded.append(`code_verifier`, oAuthTokenRequestDto.code_verifier)
 }
if(oAuthTokenRequestDto.redirect_uri !== undefined) {
 formUrlEncoded.append(`redirect_uri`, oAuthTokenRequestDto.redirect_uri)
 }
if(oAuthTokenRequestDto.refresh_token !== undefined) {
 formUrlEncoded.append(`refresh_token`, oAuthTokenRequestDto.refresh_token)
 }
if(oAuthTokenRequestDto.scope !== undefined) {
 formUrlEncoded.append(`scope`, oAuthTokenRequestDto.scope)
 }

  return clientMutator<oAuthControllerTokenResponse>(getOAuthControllerTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}




export const getOAuthControllerTokenMutationOptions = <TError = OAuthErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerToken>>, TError,{data: OAuthTokenRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerToken>>, TError,{data: OAuthTokenRequestDto}, TContext> => {

const mutationKey = ['oAuthControllerToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof oAuthControllerToken>>, {data: OAuthTokenRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  oAuthControllerToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OAuthControllerTokenMutationResult = NonNullable<Awaited<ReturnType<typeof oAuthControllerToken>>>
    export type OAuthControllerTokenMutationBody = OAuthTokenRequestDto
    export type OAuthControllerTokenMutationError = OAuthErrorResponseDto

    /**
 * @summary OAuth 2.1 Token Endpoint
 */
export const useOAuthControllerToken = <TError = OAuthErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerToken>>, TError,{data: OAuthTokenRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof oAuthControllerToken>>,
        TError,
        {data: OAuthTokenRequestDto},
        TContext
      > => {

      const mutationOptions = getOAuthControllerTokenMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generates authorization code with PKCE for mobile clients or via PAR for confidential clients. Supports request_uri from POST /oauth/par (RFC 9126). Requires system browser (no embedded WebViews per RFC 8252). Redirects to redirect_uri with code and state parameters.
 * @summary OAuth 2.1 Authorization Endpoint
 */
export type authorizeControllerAuthorizeResponse302 = {
  data: void
  status: 302
}

export type authorizeControllerAuthorizeResponse401 = {
  data: void
  status: 401
}
    
;
export type authorizeControllerAuthorizeResponseError = (authorizeControllerAuthorizeResponse302 | authorizeControllerAuthorizeResponse401) & {
  headers: Headers;
};

export type authorizeControllerAuthorizeResponse = (authorizeControllerAuthorizeResponseError)

export const getAuthorizeControllerAuthorizeUrl = (params?: AuthorizeControllerAuthorizeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/oauth/authorize?${stringifiedParams}` : `/api/oauth/authorize`
}

export const authorizeControllerAuthorize = async (params?: AuthorizeControllerAuthorizeParams, options?: RequestInit): Promise<authorizeControllerAuthorizeResponse> => {
  
  return clientMutator<authorizeControllerAuthorizeResponse>(getAuthorizeControllerAuthorizeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getAuthorizeControllerAuthorizeInfiniteQueryKey = (params?: AuthorizeControllerAuthorizeParams,) => {
    return [
    'infinite', `/api/oauth/authorize`, ...(params ? [params]: [])
    ] as const;
    }

export const getAuthorizeControllerAuthorizeQueryKey = (params?: AuthorizeControllerAuthorizeParams,) => {
    return [
    `/api/oauth/authorize`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getAuthorizeControllerAuthorizeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>, TError = void>(params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthorizeControllerAuthorizeInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authorizeControllerAuthorize>>> = ({ signal }) => authorizeControllerAuthorize(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthorizeControllerAuthorizeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>
export type AuthorizeControllerAuthorizeInfiniteQueryError = void


export function useAuthorizeControllerAuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>, TError = void>(
 params: undefined |  AuthorizeControllerAuthorizeParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>,
          TError,
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthorizeControllerAuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>, TError = void>(
 params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>,
          TError,
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthorizeControllerAuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>, TError = void>(
 params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary OAuth 2.1 Authorization Endpoint
 */

export function useAuthorizeControllerAuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>, TError = void>(
 params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthorizeControllerAuthorizeInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAuthorizeControllerAuthorizeQueryOptions = <TData = Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError = void>(params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthorizeControllerAuthorizeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authorizeControllerAuthorize>>> = ({ signal }) => authorizeControllerAuthorize(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000, gcTime: 300000, retry: 2, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthorizeControllerAuthorizeQueryResult = NonNullable<Awaited<ReturnType<typeof authorizeControllerAuthorize>>>
export type AuthorizeControllerAuthorizeQueryError = void


export function useAuthorizeControllerAuthorize<TData = Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError = void>(
 params: undefined |  AuthorizeControllerAuthorizeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>,
          TError,
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthorizeControllerAuthorize<TData = Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError = void>(
 params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>,
          TError,
          Awaited<ReturnType<typeof authorizeControllerAuthorize>>
        > , 'initialData'
      >, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthorizeControllerAuthorize<TData = Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError = void>(
 params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary OAuth 2.1 Authorization Endpoint
 */

export function useAuthorizeControllerAuthorize<TData = Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError = void>(
 params?: AuthorizeControllerAuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authorizeControllerAuthorize>>, TError, TData>>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthorizeControllerAuthorizeQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Verifies mobile device legitimacy via iOS App Attest or Android Play Integrity. Returns short-lived attestation token for use in authorization code exchange.
 * @summary Device Attestation for Mobile Clients
 */
export type attestControllerAttestResponse200 = {
  data: AttestResponseDto
  status: 200
}

export type attestControllerAttestResponse401 = {
  data: void
  status: 401
}

export type attestControllerAttestResponse415 = {
  data: void
  status: 415
}
    
export type attestControllerAttestResponseSuccess = (attestControllerAttestResponse200) & {
  headers: Headers;
};
export type attestControllerAttestResponseError = (attestControllerAttestResponse401 | attestControllerAttestResponse415) & {
  headers: Headers;
};

export type attestControllerAttestResponse = (attestControllerAttestResponseSuccess | attestControllerAttestResponseError)

export const getAttestControllerAttestUrl = () => {


  

  return `/api/oauth/attest`
}

export const attestControllerAttest = async (attestRequestDto: AttestRequestDto, options?: RequestInit): Promise<attestControllerAttestResponse> => {
  
  return clientMutator<attestControllerAttestResponse>(getAttestControllerAttestUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      attestRequestDto,)
  }
);}




export const getAttestControllerAttestMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof attestControllerAttest>>, TError,{data: AttestRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof attestControllerAttest>>, TError,{data: AttestRequestDto}, TContext> => {

const mutationKey = ['attestControllerAttest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof attestControllerAttest>>, {data: AttestRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  attestControllerAttest(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AttestControllerAttestMutationResult = NonNullable<Awaited<ReturnType<typeof attestControllerAttest>>>
    export type AttestControllerAttestMutationBody = AttestRequestDto
    export type AttestControllerAttestMutationError = void

    /**
 * @summary Device Attestation for Mobile Clients
 */
export const useAttestControllerAttest = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof attestControllerAttest>>, TError,{data: AttestRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof attestControllerAttest>>,
        TError,
        {data: AttestRequestDto},
        TContext
      > => {

      const mutationOptions = getAttestControllerAttestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Validates access tokens and returns metadata. Requires confidential client authentication (Basic Auth).
 * @summary Token Introspection (RFC 7662)
 */
export type oAuthControllerIntrospectResponse200 = {
  data: OAuthIntrospectResponseDto
  status: 200
}

export type oAuthControllerIntrospectResponse401 = {
  data: OAuthErrorResponseDto
  status: 401
}
    
export type oAuthControllerIntrospectResponseSuccess = (oAuthControllerIntrospectResponse200) & {
  headers: Headers;
};
export type oAuthControllerIntrospectResponseError = (oAuthControllerIntrospectResponse401) & {
  headers: Headers;
};

export type oAuthControllerIntrospectResponse = (oAuthControllerIntrospectResponseSuccess | oAuthControllerIntrospectResponseError)

export const getOAuthControllerIntrospectUrl = () => {


  

  return `/api/oauth/introspect`
}

export const oAuthControllerIntrospect = async (oAuthIntrospectRequestDto: OAuthIntrospectRequestDto, options?: RequestInit): Promise<oAuthControllerIntrospectResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`token`, oAuthIntrospectRequestDto.token)
if(oAuthIntrospectRequestDto.token_type_hint !== undefined) {
 formUrlEncoded.append(`token_type_hint`, oAuthIntrospectRequestDto.token_type_hint)
 }

  return clientMutator<oAuthControllerIntrospectResponse>(getOAuthControllerIntrospectUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}




export const getOAuthControllerIntrospectMutationOptions = <TError = OAuthErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerIntrospect>>, TError,{data: OAuthIntrospectRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerIntrospect>>, TError,{data: OAuthIntrospectRequestDto}, TContext> => {

const mutationKey = ['oAuthControllerIntrospect'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof oAuthControllerIntrospect>>, {data: OAuthIntrospectRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  oAuthControllerIntrospect(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OAuthControllerIntrospectMutationResult = NonNullable<Awaited<ReturnType<typeof oAuthControllerIntrospect>>>
    export type OAuthControllerIntrospectMutationBody = OAuthIntrospectRequestDto
    export type OAuthControllerIntrospectMutationError = OAuthErrorResponseDto

    /**
 * @summary Token Introspection (RFC 7662)
 */
export const useOAuthControllerIntrospect = <TError = OAuthErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerIntrospect>>, TError,{data: OAuthIntrospectRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof oAuthControllerIntrospect>>,
        TError,
        {data: OAuthIntrospectRequestDto},
        TContext
      > => {

      const mutationOptions = getOAuthControllerIntrospectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Revokes access or refresh tokens. Requires confidential client authentication (Basic Auth). Always returns 200 OK per RFC 7009.
 * @summary Token Revocation (RFC 7009)
 */
export type oAuthControllerRevokeResponse200 = {
  data: void
  status: 200
}

export type oAuthControllerRevokeResponse401 = {
  data: OAuthErrorResponseDto
  status: 401
}
    
export type oAuthControllerRevokeResponseSuccess = (oAuthControllerRevokeResponse200) & {
  headers: Headers;
};
export type oAuthControllerRevokeResponseError = (oAuthControllerRevokeResponse401) & {
  headers: Headers;
};

export type oAuthControllerRevokeResponse = (oAuthControllerRevokeResponseSuccess | oAuthControllerRevokeResponseError)

export const getOAuthControllerRevokeUrl = () => {


  

  return `/api/oauth/revoke`
}

export const oAuthControllerRevoke = async (oAuthRevokeRequestDto: OAuthRevokeRequestDto, options?: RequestInit): Promise<oAuthControllerRevokeResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`token`, oAuthRevokeRequestDto.token)
if(oAuthRevokeRequestDto.token_type_hint !== undefined) {
 formUrlEncoded.append(`token_type_hint`, oAuthRevokeRequestDto.token_type_hint)
 }

  return clientMutator<oAuthControllerRevokeResponse>(getOAuthControllerRevokeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}




export const getOAuthControllerRevokeMutationOptions = <TError = OAuthErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerRevoke>>, TError,{data: OAuthRevokeRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerRevoke>>, TError,{data: OAuthRevokeRequestDto}, TContext> => {

const mutationKey = ['oAuthControllerRevoke'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof oAuthControllerRevoke>>, {data: OAuthRevokeRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  oAuthControllerRevoke(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OAuthControllerRevokeMutationResult = NonNullable<Awaited<ReturnType<typeof oAuthControllerRevoke>>>
    export type OAuthControllerRevokeMutationBody = OAuthRevokeRequestDto
    export type OAuthControllerRevokeMutationError = OAuthErrorResponseDto

    /**
 * @summary Token Revocation (RFC 7009)
 */
export const useOAuthControllerRevoke = <TError = OAuthErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof oAuthControllerRevoke>>, TError,{data: OAuthRevokeRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof oAuthControllerRevoke>>,
        TError,
        {data: OAuthRevokeRequestDto},
        TContext
      > => {

      const mutationOptions = getOAuthControllerRevokeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Allows confidential clients to push authorization parameters to the server before redirecting the user. Returns a request_uri to use in /oauth/authorize. Requires client authentication (HTTP Basic or POST body).
 * @summary Pushed Authorization Request (RFC 9126)
 */
export type pARControllerPushAuthorizationRequestResponse201 = {
  data: PARResponseDto
  status: 201
}

export type pARControllerPushAuthorizationRequestResponse400 = {
  data: void
  status: 400
}

export type pARControllerPushAuthorizationRequestResponse401 = {
  data: void
  status: 401
}

export type pARControllerPushAuthorizationRequestResponse415 = {
  data: void
  status: 415
}
    
export type pARControllerPushAuthorizationRequestResponseSuccess = (pARControllerPushAuthorizationRequestResponse201) & {
  headers: Headers;
};
export type pARControllerPushAuthorizationRequestResponseError = (pARControllerPushAuthorizationRequestResponse400 | pARControllerPushAuthorizationRequestResponse401 | pARControllerPushAuthorizationRequestResponse415) & {
  headers: Headers;
};

export type pARControllerPushAuthorizationRequestResponse = (pARControllerPushAuthorizationRequestResponseSuccess | pARControllerPushAuthorizationRequestResponseError)

export const getPARControllerPushAuthorizationRequestUrl = () => {


  

  return `/api/oauth/par`
}

export const pARControllerPushAuthorizationRequest = async (pARRequestDto: PARRequestDto, options?: RequestInit): Promise<pARControllerPushAuthorizationRequestResponse> => {
  
  return clientMutator<pARControllerPushAuthorizationRequestResponse>(getPARControllerPushAuthorizationRequestUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pARRequestDto,)
  }
);}




export const getPARControllerPushAuthorizationRequestMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pARControllerPushAuthorizationRequest>>, TError,{data: PARRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
): UseMutationOptions<Awaited<ReturnType<typeof pARControllerPushAuthorizationRequest>>, TError,{data: PARRequestDto}, TContext> => {

const mutationKey = ['pARControllerPushAuthorizationRequest'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pARControllerPushAuthorizationRequest>>, {data: PARRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  pARControllerPushAuthorizationRequest(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PARControllerPushAuthorizationRequestMutationResult = NonNullable<Awaited<ReturnType<typeof pARControllerPushAuthorizationRequest>>>
    export type PARControllerPushAuthorizationRequestMutationBody = PARRequestDto
    export type PARControllerPushAuthorizationRequestMutationError = void

    /**
 * @summary Pushed Authorization Request (RFC 9126)
 */
export const usePARControllerPushAuthorizationRequest = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pARControllerPushAuthorizationRequest>>, TError,{data: PARRequestDto}, TContext>, request?: SecondParameter<typeof clientMutator>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pARControllerPushAuthorizationRequest>>,
        TError,
        {data: PARRequestDto},
        TContext
      > => {

      const mutationOptions = getPARControllerPushAuthorizationRequestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    